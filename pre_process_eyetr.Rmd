---
title: "eyetracking pre-procesing - social vs non social modualtion of emotion response and physilogy"
author: "Helio"
date: "2024-03-07"
output: html_document
---



# Overview 
In this file I aim to process all the gaze data, essentially read, clean and combines multiple files with gaze data and their metadata

# Conventions
For data: dta_
Temporary files: tmp_
Statistical summaries: sum_
Models (such as lm models): mod_
Custom functions: fn_
Plots and visualization: plt_
Lookup and referecne tables: lkp_
Results and Analysis: rlt_
Consistency and accuracy checks: chk_

4. Check gaze data



Set-up: where I load libraries and create objects for later use (such as color schemes etc).


version of R

R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin20

```{r setup, include=FALSE}
# store date
current_date<- Sys.Date()

# libraries
require(tidyverse)
require(data.table)
require(readr)

# for reading hdf5 files
# if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
# BiocManager::install(version = "3.19")
# 
# BiocManager::install("rhdf5")
library(rhdf5)




```

Data Import / Cleaning: where datasets are imported and cleaned.
```{r}

# setwd("/Users/pw22812/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking")

# get hdf files in 
hdf5_file_path<-"~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking"
  
# set working directory
setwd(hdf5_file_path)

# 


```


File Listing: It lists all HDF5 files in the given directory (hdf5_file_path).

File Check: If no HDF5 files are found, it returns a message indicating this.

Loop Through Files: For each HDF5 file:

File Information: It prints a message indicating the file being processed.
Extract Events: Reads the 'MessageEvent' data from the file.
Filter Events: Keeps only the relevant events (tStart, tEnd, and those with category "VALIDATION").
Extract Eye Tracking Data: Reads the 'GazepointSampleEvent' data.
Extract Subject ID: Extracts the subject ID from the file name.
Event Processing:
Filters events to keep only start and end messages.
Creates start and end time references.
Labels events with screen content (fixation or stimuli) and trial type (practice or trial).
Extracts the stimulus file name from the event text.
Data Preparation:
Converts raw eye-tracking data to a double format.
Subsets eye-tracking data based on event start and end times.
Adds metadata (screen content, trial type, stimulus path, subject ID) to eye-tracking data.
Binds the trial data to a dataframe.
Sorting and Saving:
Sorts the dataframe by time.
Saves the processed eye-tracking data to a CSV file named with the subject ID and the current date.
Saves the calibration events to a separate CSV file.
Completion Message: Prints a message indicating that processing is completed.

Return Dataframe: Returns the dataframe with the processed data.
```{r}

# creating the fucntion
fn_gp.extractor = function(hdf5_file_path) {
  
  hdf_files_list = list.files(hdf5_file_path, pattern = "\\.hdf5$")
  
  if (length(hdf_files_list) == 0){
    
    return(message('No HDF5 files found in the directory provided.'))
  }
  hdf_files_list1 = hdf_files_list[40]
  
  # pb <- txtProgressBar(min = 0, max = length(hdf_files_list), style = 3)

  for (f in 1:length(hdf_files_list)) {
    # f = 1
    message(sprintf("Extracting file %i / %i - %s", f, length(hdf_files_list), hdf_files_list[f]))
    
    #note this sometimes fails because e are using a notebook 
    # Extract Events from hdf5, in that case run it from command
    tmp.events =h5read(hdf_files_list[f], '/data_collection/events/experiment/MessageEvent')
    
    # tmp.events1 =h5read(hdf_files_list[41], '/data_collection/events/experiment/MessageEvent')

    # tmp.events_tmp<- bind_rows(tmp.events, tmp.events1)
    # check tstop or tend
    tmp.events$keep_drop<- if_else(grepl(c('tStart'), tmp.events$text), "keep",
                                   if_else(grepl(c('tEnd'), tmp.events$text), "keep",
                                            if_else(tmp.events$category == "VALIDATION", "keep",
                                           "drop")))
    
    tmp.events<- subset(tmp.events, keep_drop == "keep")
  
  
    # load the eye tracking data
    tmp.eyetr  = h5read(hdf_files_list[f], '/data_collection/events/eyetracker/GazepointSampleEvent') # note this is
    # 
    # tmp.eyetr1  = h5read(hdf_files_list[41], '/data_collection/events/eyetracker/GazepointSampleEvent') # note this is
    #  tmp.eyetr_tmp<- bind_rows(tmp.eyetr, tmp.eyetr1)
    #  
    #  tmp.events<- tmp.events_tmp
    # tmp.eyetr<- tmp.eyetr_tmp
    
    # updated to GazepointSampleEvent whereas before it was BinocularEyeSampleEvent
    
f = 40
    # Get subejct id from Events
    ssid = sub("_.*", "", hdf_files_list[f])
      # substr(hdf_files_list[f], 1,3)
    # update the string before the data
    date = gsub('^.*Interostudy_\\s*|\\s*.hdf5*$', '', hdf_files_list[f])
    
  
    session = unique(tmp.events$session_id)

    
    # Create DF for trials data
    tmp.df = data.frame(matrix(ncol = ncol(tmp.eyetr)))
    names(tmp.df) = names(tmp.eyetr)
    colnames(tmp.df)
    
    # Prepare Events, keep only start/end messages
    phrases = c('tStart', 'tEnd')

    
    # unique(tmp.events$category)
    tmp.events_calib = subset(tmp.events, category == "VALIDATION")
    
    tmp.events = subset(tmp.events, grepl(paste(phrases, collapse = "|"), tmp.events$text))
# tmp.events    
    # we should have a total of XX stimuli multiplied by 4 (start and t end for stim and fix) 
    # 4 pratice + 48 trials = 52
    # 52*4 = we should should 208 rows
    # Create start/end references
    tmp.events$t_start   = NA
    tmp.events$t_end     = NA
    
    # Trial number extraction 
    tmp.events$t_no      = NA
    
    # Space for subject id
    tmp.df$ssid         = NA
    tmp.df$text<-NA
    
    for (l in 1:nrow(tmp.events)) {
      
      message(sprintf("Grabing start messages %s", tmp.events$text[l]))
      
      if ((grepl('tStart', tmp.events$text[l])) == TRUE) {
        tmp.events$t_start[l] = tmp.events$time[l]
        
        if ((grepl('tEnd', tmp.events$text[l+1])) == TRUE){
          tmp.events$t_end[l] = tmp.events$time[l+1]
        }
        
        else {
          message('trial start/end structure not valid')
        }
      }
      
    }
    
    message(sprintf("done grabbing messages"))
    # readline(prompt="Press [enter] to continue")
    
     message(sprintf("making screencontent"))
     # unique(tmp.events$text)
    tmp.events$screencontent <- if_else(grepl('fix', tmp.events$text), 'fixation',
                                       if_else(grepl('stim', tmp.events$text), 'stimuli', NA))
    
    
    # first let's do condition
    # update the names
    tmp.events$pratice_vs_trial<- if_else(grepl('Example', tmp.events$text), 'Pratice',
                                   if_else(grepl('IAPS', tmp.events$text), 'Trial', NA))
    
 
    # store stim code here -0 we need the content between "_" and ".jpg
    tmp.events$stimnopath<-   paste0(sub(".*_(.*?)\\.jpg.*", "\\1", tmp.events$text), ".jpg")
      
      
    
    # tmp.events$emotion_yes_no_new<- 
    
    tmp.events1 = subset(tmp.events, grepl('tStart',tmp.events$text))
 

    tmp.df$screencontent<- NA
    tmp.df$pratice_vs_trial <- NA
    # tmp.df$isfakeOrReal <- NULL
    tmp.df$stimnopath <- NA
    
    # e=10
        message(sprintf("subsetting eyetracking data"))
    
        tmp.events1$ssid<- ssid
        
        # why?
tmp.eyetr<-tmp.eyetr%>%
  mutate_if(is.raw, as.double)

for(e in 1:nrow(tmp.events1)) {
      # e = 1
      # Subset the EyeTracking data based on start/end
      tmp.raw.trial = subset(tmp.eyetr, 
                             tmp.eyetr$time >= tmp.events1$t_start[e] & tmp.eyetr$time <= tmp.events1$t_end [e]+.5)
      
      # tmp.raw.trial$tNo = tmp.events1$tNo[e]
      # tmp.events1$tNo<-NULL
      
      tmp.raw.trial$screencontent = tmp.events1$screencontent[e]
      tmp.raw.trial$pratice_vs_trial = tmp.events1$pratice_vs_trial[e]
      # tmp.raw.trial$isfakeOrReal = tmp.events1$isfakeOrReal[e]
      tmp.raw.trial$stimnopath = tmp.events1$stimnopath[e]
      # tmp.raw.trial$stim = tmp.events1$[e]
      tmp.raw.trial$ssid = ssid
      tmp.raw.trial$text = tmp.events1$text[e]
       message(sprintf("binding tmp.df"))
       
      tmp.df<- rbind(tmp.raw.trial,tmp.df)

}

        
     message(sprintf("done binding"))
    
    # Add ssid
    # tmp.df$ssID = ssid[e]
    tmp.df<- tmp.df%>%
      arrange(time)
    
     ###########################
    # Save file
    
    name = sprintf("%s_",ssid)
    message(sprintf("saving data"))
    write.csv(tmp.df, paste0(name,Sys.Date(), paste0("_gp_data.csv")))#
    # write.csv(tmp.df, paste0(name,Sys.Date(), paste0(".csv")))#
    
    ###########################
    # write calibration cali
    name2 = sprintf("%s_", ssid)
    write.csv(tmp.events_calib, paste0(name2,Sys.Date(), paste0("_gp_data_cali.csv")))#
      
    #   sprintf("ss%s_GPdata_cali", ssid)
    # write.csv(tmp.events_calib, paste0(name2,Sys.Date(), paste0(".csv")))#
    
  }
  

  message("Processing Completed.")
  tmp.df
  # close(pb)
}

# tmp.df%>%
#   group_by(text)%>%
#   mutate(diff_time = time-lag(time))%>%
#   mutate(cum_diff = sum(abs(diff_time), na.rm = T))%>%
#   ggplot(aes(cum_diff))+
#   geom_histogram()+
#   facet_grid(~screencontent)
# 
# table(is.na(tmp.df$screencontent))


```

run the fn_gp.extractor

140 had to be re-run separately due to slit session

```{r }

# not this throws an error on problematic participants
tmp_full<- fn_gp.extractor(hdf5_file_path)




tmp_test<-fn_gp.extractor(hdf_files_list[40])

tmp_full

```




Now some basic cleaning 

```{r, cleaning}
# setwd("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/raw")

# reads all individual gaze exported files into one big file

library(readr)
# colnames(X101_2024_03_07_gp_data)


read_plus <- function(flnm) {
  data.table::fread(flnm, select = c( "ssid", "session_id","event_id", "time", "left_gaze_x", "left_gaze_y","right_gaze_x", "right_gaze_y","left_pupil_measure1",
                                     "right_pupil_measure1",
                                     "left_pupil_measure2",
                                     "right_pupil_measure2",
                                     "status", 
                                     "screencontent",
                                     "pratice_vs_trial",
                                     "stimnopath",
                                     
                                     "text")) %>% 
    mutate(filename = flnm)
}


# read all clean data 

dta_eytr <-
  list.files(pattern = "*data.csv", 
             full.names = T) %>% 
  map_df(~read_plus(.))%>%
  janitor::clean_names()%>%
  subset(!is.na(ssid))

# three digits?
# Regular expression to capture the pattern before "_" and after "./"
pattern <- "\\./([0-9]+)_.*"

# Extract the pattern
unique(dta_eytr$stimnopath)

length(unique(dta_eytr$ssid))
length(unique(sub(pattern, "\\1", dta_eytr$filename)))

dta_eytr$participant<-  sub(pattern, "\\1", dta_eytr$filename)
# dta_eytr$participant<-  dta_eytr$ssid





dta_eyetrack

unique(dta_eytr$screencontent)

dta_eytr$screencontent_no_na <- if_else(is.na(dta_eytr$screencontent), "rest", dta_eytr$screencontent)

dta_eytr$stimnopath_no_na <- if_else(is.na(dta_eytr$stimnopath), "rest", 
                                   if_else(dta_eytr$stimnopath == "tStart_rest1_cross", "rest",       
                                           dta_eytr$stimnopath))

unique(dta_eytr$text)
  
```




#####################################################################################
# gp preprocessing funtion, checks for losses, averages gaze, pupil and pixelate
#####################################################################################

```{r, gppreprocessing}

unique(dta_eytr$status)

fn_gp_preprocessing = function(dta_eytr) {
  
  message(sprintf("step1 left gaze validity"))
  
  # transform invalid gaze into NA based on validity codes
  # to do: link the conventions file
  
#   status - https://psychopy.org/api/iohub/device/eyetracker_interface/GazePoint_Implementation_Notes.html
# Indicates if eye sample contains ‘valid’ data for left and right eyes. 
  # 0 = Eye sample is OK. 2 = Right eye data is likely invalid. 20 = Left #eye data is likely invalid. 22 = Eye sample is likely invalid.
  dta_eytr$left_gaze_x_cor<- if_else(dta_eytr$status != '20', dta_eytr$left_gaze_x, NA)
  dta_eytr$left_gaze_x_cor<- if_else(dta_eytr$status != '22', dta_eytr$left_gaze_x_cor, NA)
  dta_eytr$left_gaze_y_cor<- if_else(dta_eytr$status != '20', dta_eytr$left_gaze_y, NA)
  dta_eytr$left_gaze_y_cor<- if_else(dta_eytr$status != '22', dta_eytr$left_gaze_y_cor, NA)
  
  message(sprintf("step2 right gaze validity"))
  
  dta_eytr$right_gaze_x_cor<- if_else(dta_eytr$status != '2', dta_eytr$right_gaze_x, NA)
  #
  dta_eytr$right_gaze_x_cor<- if_else(dta_eytr$status != '22', dta_eytr$right_gaze_x_cor, NA)
  dta_eytr$right_gaze_y_cor<- if_else(dta_eytr$status != '2', dta_eytr$right_gaze_y, NA)
  dta_eytr$right_gaze_y_cor<- if_else(dta_eytr$status != '22', dta_eytr$right_gaze_y_cor, NA)

  # pupil validity
  
  message(sprintf("step3 pupil validity"))
  # pupil pixels
  dta_eytr$left_pupil_measure1<- if_else(dta_eytr$status != '20', dta_eytr$left_pupil_measure1, NA)
  dta_eytr$left_pupil_measure1<- if_else(dta_eytr$status != '22', dta_eytr$left_pupil_measure1, NA)
  
  dta_eytr$right_pupil_measure1<- if_else(dta_eytr$status != '2', dta_eytr$right_pupil_measure1, NA)
  dta_eytr$right_pupil_measure1<- if_else(dta_eytr$status != '22', dta_eytr$right_pupil_measure1, NA)
  table(is.na(dta_eytr$right_pupil_measure1))
  
  # pupil diameter
  
   dta_eytr$left_pupil_measure2<- if_else(dta_eytr$status != '20', dta_eytr$left_pupil_measure2, NA)
  dta_eytr$left_pupil_measure2<- if_else(dta_eytr$status != '22', dta_eytr$left_pupil_measure2, NA)
  
  dta_eytr$right_pupil_measure2<- if_else(dta_eytr$status != '2', dta_eytr$right_pupil_measure2, NA)
  dta_eytr$right_pupil_measure2<- if_else(dta_eytr$status != '22', dta_eytr$right_pupil_measure2, NA)
  table(is.na(dta_eytr$right_pupil_measure2))
  
  # check gazepoint out of bounds and repixelate 
  
  # screen=1, size=array([1920, 1080]) # update here accordingly
  
  # (1920/2 = 960 by 1080/2 = 540 add half to normalised coordinates from psychopy)
  # update according to setup
  
  message(sprintf("step 4 cutting off screen in points and repixelate"))
  
  dta_eytr$left_gaze_x_cor<- if_else(dta_eytr$left_gaze_x_cor >= -960 & dta_eytr$left_gaze_x_cor <= 960, dta_eytr$left_gaze_x_cor, NA)
  dta_eytr$right_gaze_x_cor<- if_else(dta_eytr$right_gaze_x_cor >= -960 & dta_eytr$right_gaze_x_cor <= 960, dta_eytr$right_gaze_x_cor, NA)
  
  dta_eytr$left_gaze_y_cor<- if_else(dta_eytr$left_gaze_y_cor >= -540 & dta_eytr$left_gaze_y_cor <= 540, dta_eytr$left_gaze_y_cor, NA)
  dta_eytr$right_gaze_y_cor<- if_else(dta_eytr$right_gaze_y_cor >= -540 & dta_eytr$right_gaze_y_cor <= 540, dta_eytr$right_gaze_y_cor, NA)
  
  dta_eytr$left_gaze_x_cor_pix<- dta_eytr$left_gaze_x_cor+960
  dta_eytr$right_gaze_x_cor_pix<- dta_eytr$right_gaze_x_cor+960
  
  dta_eytr$left_gaze_y_cor_pix<- dta_eytr$left_gaze_y_cor+540
  dta_eytr$right_gaze_y_cor_pix<- dta_eytr$right_gaze_y_cor+540
  
  # is left or right an NA
  
  dta_eytr$left_na<- is.na(dta_eytr$left_gaze_x_cor) 
  dta_eytr$right_na<- is.na(dta_eytr$right_gaze_x_cor)
  dta_eytr$both_na<- if_else(dta_eytr$left_na == TRUE & dta_eytr$right_na == TRUE, TRUE, FALSE)
  
  message(sprintf("step5 gaze x  means"))
  # create gaze means betwenn left and right eye
  
  dta_eytr$gaze_x_cor<-if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_gaze_x_cor,
                              if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_gaze_x_cor,
                                      ((dta_eytr$left_gaze_x_cor + dta_eytr$right_gaze_x_cor)/2)))
  message(sprintf("step6 gaze y means"))
  
  dta_eytr$gaze_y_cor<-if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_gaze_y_cor,
                              if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_gaze_y_cor,
                                      ((dta_eytr$left_gaze_y_cor + dta_eytr$right_gaze_y_cor)/2)))
  
  message(sprintf("step6 repixelate gaze means"))
  
  dta_eytr$gaze_x_cor_pix<- dta_eytr$gaze_x_cor + 960
  # min(dta_eytr$gaze_x_cor_pix, na.rm = TRUE)
  
  dta_eytr$gaze_y_cor_pix<- dta_eytr$gaze_y_cor+540
  # min(dta_eytr$gaze_y_cor_pix, na.rm = TRUE)
  
  # clean_pupil
  
  message(sprintf("cleaning pupil"))
  
  # max(dta_eytr$left_pupil_measure1)
  
  dta_eytr$pupil<- if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_pupil_measure1,
                          if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_pupil_measure1,
                                  ((dta_eytr$left_pupil_measure1 + dta_eytr$right_pupil_measure1)/2)))
  
  
  # diameter
  dta_eytr$pupil_d<- if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_pupil_measure2,
                          if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_pupil_measure2,
                                  ((dta_eytr$left_pupil_measure2 + dta_eytr$right_pupil_measure2)/2)))
  
  
  # dta_eytr$trackloss<- if_else(dta_eytr$status > 0, TRUE, FALSE)
  dta_eytr$trialunq<- paste0(dta_eytr$pratice_vs_trial,"_",paste0(dta_eytr$screencontent,"_", paste0(dta_eytr$stimnopath_no_na)))
  dta_eytr$distance_mm = 600
  
  # min(dta_eytr$pupil, na.rm = TRUE)
  # max(dta_eytr$pupil, na.rm = TRUE)
  # colnames(dta_eytr)
  dta_eytr<- dta_eytr%>%
    # group_by(ssid)
    arrange(ssid,time)
}


# unique(paste0(dta_eytr$pratice_vs_trial,"_",paste0(dta_eytr$screencontent,"_", paste0(dta_eytr$stimnopath_no_na))))

# paste0(dta_eytr$pratice_vs_trial,"_",paste0(dta_eytr$screencontent,"_", paste0(dta_eytr$stim)))


# trialunq is wrong
```

repixelated and minimally processed (e.g. deleting invalid samples), merging left and right eye
```{r}
rm(gp_preprocessing)
dta_eytr_rpx<- fn_gp_preprocessing(dta_eytr)


colnames(dta_eytr_rpx) 
 
options(scipen = 999)
options(scipen = 999)
range(dta_eytr_rpx$pupil, na.rm = TRUE)
range(dta_eytr_rpx$pupil_d, na.rm = TRUE)
range(dta_eytr_rpx$gaze_y_cor_pix, na.rm = TRUE)
range(dta_eytr_rpx$gaze_x_cor_pix, na.rm = TRUE) 

# split and export per participant

colnames(dta_eytr_rpx)

unique(dta_eytr_rpx$stimnopath)

dta_eytr_rpx<- dta_eytr_rpx%>%
  group_by(participant)%>%
  arrange(time)


# Split the dataframe based on 'group_column'
list_of_dfs <- split(dta_eytr_rpx, dta_eytr_rpx$participant)

colnames(dta_eytr_rpx)

# Iterate over the list to write each dataframe to a CSV file
lapply(names(list_of_dfs), function(x) {
  csv_filename <- paste0(x, "_dta_eytr_rpx.csv")
  write.csv(list_of_dfs[[x]], csv_filename, row.names = FALSE)
})

```
quick checks
```{r}
dta_eytr_rpx%>%
  group_by(participant)%>%
  arrange(time)%>%
  
  mutate(tmp_group = paste0(stimnopath_no_na,screencontent_no_na))%>%
  group_by(tmp_group)%>%
 
  subset(participant == 117& screencontent_no_na != "rest")%>%
   mutate(time_rezero = time - first(time)) %>%
  ggplot(aes(time_rezero, gaze_x_cor_pix))+
    geom_line()+
    geom_line(aes(y = gaze_y_cor_pix), colour = "blue")+
  facet_grid(~screencontent_no_na)+
  geom_vline(xintercept = 6.6, linetype = "dashed", colour ="red")+
  ylab("gaze coordinates")



dta_eytr_rpx%>%
  group_by(participant)%>%
  arrange(time)%>%
  
  mutate(tmp_group = paste0(stimnopath_no_na,screencontent_no_na))%>%
  group_by(tmp_group)%>%
 
  subset(participant == 117& screencontent_no_na != "rest")%>%
   mutate(time_rezero = time - first(time)) %>%
  ggplot(aes(time_rezero, pupil))+
    geom_smooth(aes(group = stimnopath_no_na), se = F)+
    # geom_line(aes(y = gaze_y_cor_pix), colour = "blue")+
  facet_grid(~screencontent_no_na)+
  geom_vline(xintercept = 6.6, linetype = "dashed", colour ="red")
  ylab("gaze coordinates")



```



######################
# rezeroing times by trial, by participants


```{r}
dta_eytr_rpx
# create start at every screen content
# Preview unique screen contents and dataset structure
print(unique(dta_eytr_rpx$text))
print(colnames(dta_eytr_rpx))


unique(dta_eytr_rpx$trialunq)
unique(dta_eytr_rpx$pratice_vs_trial)
unique(dta_eytr_rpx$screencontent)
unique(dta_eytr_rpx$screencontent_no_na)
dta_eytr_rpx$trialunq
# only run this is the previous processing code is not fixed where trialunq includes pratice vs trial


dta_eytr_rpx$pratice_vs_trial<- ifelse(is.na(dta_eytr_rpx$pratice_vs_trial), "rest", dta_eytr_rpx$pratice_vs_trial)


dta_eytr_rpx$trialunq<- paste0(dta_eytr_rpx$pratice_vs_trial,"_",paste0(dta_eytr_rpx$screencontent,"_", paste0(dta_eytr_rpx$stimnopath_no_na)))

table(is.na(dta_eytr_rpx$trialunq))

unique(dta_eytr_rpx$trialunq)
unique(dta_eytr_rpx$text)


dta_eytr_rpx <- dta_eytr_rpx %>%
  arrange(participant, time) %>%
  group_by(ssid, screencontent_no_na) %>%
  mutate(is_firststart = !duplicated(trialunq)) %>%
  ungroup()# Use '!' to correctly identify the first start

# Preview the data to ensure the above operation worked as intended
print(head(dta_eytr_rpx))

# Create a zero-time column where the first occurrence of each trial is marked with its time, others as NA
dta_eytr_rpx <- dta_eytr_rpx %>%
  mutate(zero = if_else(is_firststart, time, NA_real_)) # Use NA_real_ for consistency in numeric columns

# Propagate the zero times down each group to fill in the NAs
dta_eytr_rpx <- dta_eytr_rpx %>%
  group_by(ssid, screencontent_no_na, trialunq) %>%
  fill(zero, .direction = "down")%>% # Explicitly mention direction for clarity
  ungroup()

# Calculate the time relative to zero for each trial
dta_eytr_rpx <- dta_eytr_rpx %>%
  mutate(timerezero = time - zero)

# Arrange by time for final organization, if necessary
dta_eytr_rpx <- dta_eytr_rpx %>%
  arrange(participant, time)

dta_eytr_rpx140<- dta_eytr_rpx%>%
  subset(ssid == 140)


dta_eytr_rpx<- dta_eytr_rpx%>%
  subset(ssid != 140)

unique(dta_eytr_rpx140$screencontent)
unique(dta_eytr_rpx140$screencontent_no_na)

dta_eytr_rpx140<- dta_eytr_rpx140%>%
  mutate(rest_1_trial_2 = if_else(dta_eytr_rpx140$screencontent_no_na == "rest",1,2 ))%>%
  arrange(rest_1_trial_2, time)

# > 1705.112-1705.105
# [1] 0.007
# [1] 2
# > 1/150
# [1] 0.006666667

dta_eytr_rpx<- bind_rows(dta_eytr_rpx,dta_eytr_rpx140)


```

# Optionally, print unique zero times to verify the operation
print(unique(dta_eytr_rpx$zero))

# Results stored in 'dta_gaze_clean' with 'timerezero' reflecting time since trial start



# create a new time rezero where before stim start, time is negative
```{r}

dta_eytr_rpx$timerezero

dta_eytr_rpx<- dta_eytr_rpx %>%
  group_by(participant, stimnopath_no_na) %>%
  arrange(participant, time) %>%
  mutate(general_time = row_number() - 1) %>% # This assumes your data starts from 0 and increments
  group_by(ssid, stimnopath_no_na, screencontent_no_na, .add = TRUE) %>%
  mutate(
    backward_time = max(timerezero) - timerezero, # Calculate backward time for fixation
    time_backward = case_when(
      screencontent_no_na == "stimuli" ~ timerezero, # Use timezero directly for forward time in stimuli
      screencontent_no_na == "fixation" ~ -backward_time, # Use negative backward time for fixation
      TRUE ~ NA_real_ # Fallback case
    )
  ) %>%
  ungroup()



dta_eytr_rpx%>%
subset(ssid == 116 & screencontent_no_na!= "rest") %>%
ggplot( aes(time_backward, pupil ))+
  geom_smooth(aes(group = stimnopath_no_na), se = F, size = .1)+
  geom_vline(xintercept = 0, linetype = "dashed")
    # facet_grid(~screencontent_no_na)
  



  

```



# Filter out rows where either event_id or time is duplicated within each ssid

```{r eval=FALSE, include=FALSE}

dta_eytr_rpx <- dta_eytr_rpx %>%
  group_by(participant) %>%
  mutate(duplicated_event_id = duplicated(event_id) | duplicated(event_id, fromLast = TRUE),
         duplicated_time = duplicated(time) | duplicated(time, fromLast = TRUE)) %>%
  ungroup()

table(dta_eytr_rpx$duplicated_event_id)



dta_eytr_rpx_nodup <- dta_eytr_rpx %>%
  filter(!duplicated_event_id & !duplicated_time)


tmp_test<-  dta_eytr_rpx %>%
  subset(duplicated_event_id & duplicated_time)
nrow(dta_eytr_rpx_nodup )/nrow(dta_eytr_rpx)         
# 0.8980762

# don'\t subset as this sems to happen at the end or start of screens and mighht cutout our isfirst start -==- TRUE
```



select variables for gazepath
```{r}
dta_eytr_rpx$ssid
dta_eytr_rpx$participant
dta_eytr_rpx$subject <- dta_eytr_rpx$ssid


# correct the isues with trial unique indicator

  dta_eytr_rpx$trialunq<- paste0(dta_eytr_rpx$pratice_vs_trial,"_",paste0(dta_eytr_rpx$screencontent,"_", paste0(dta_eytr_rpx$stimnopath_no_na)))

unique(  dta_eytr_rpx$trialunq) #expect 129 (64 trials * 2 (fixationa trial) + 1 rest)
# 
dta_eytr_rpx<- dta_eytr_rpx%>%
 mutate(rest_1_trial_2 = if_else(screencontent_no_na == "rest",1,2 ))%>% # we need to do this because of 140 time issues
group_by(participant)%>%
  arrange(rest_1_trial_2,time)

dta_eytr_rpx%>%
  subset(participant==140)


dta_eytr_rpx$distance_mm <- 650



dta_eytr_rpx$trackloss<- if_else(is.na(dta_eytr_rpx$gaze_x_cor_pix) == TRUE, 0, 
                         if_else(is.na(dta_eytr_rpx$gaze_y_cor_pix) == TRUE, 0, 1))

unique(dta_eytr_rpx$trackloss)

# compute proportion of lost data

# dta_gaze_clean_10s_nodup$trialunq #problematic

dta_eytr_rpx <- dta_eytr_rpx %>%
  group_by(participant, text)%>%
  mutate(gaze_valid_prop = sum(trackloss)/n())%>%
  mutate(gaze_loss_prop = 1 - gaze_valid_prop)%>%
  group_by(participant)%>%
  arrange(time)%>%
  ungroup()


# check to see this is right

dta_eytr_rpx%>%
  ggplot(aes(gaze_loss_prop))+
  geom_histogram()

dta_eytr_rpx%>%
  ggplot(aes(gaze_valid_prop))+
  geom_histogram()
```


select for gazepath
```{r}
dta_eytr_rpx$filename


dta_eytr_rpx$trialunq

dta_4gazepath<- select(dta_eytr_rpx, 
                                      c("participant", "session_id", "event_id", "ssid", 
                                        "text","trialunq","screencontent",
                                        "screencontent_no_na","pratice_vs_trial",                           "stimnopath",
                                        "stimnopath_no_na",
                            "time", "timerezero","time_backward",
                            "status",
                            "filename",
                            "left_gaze_x_cor_pix",
                            "right_gaze_x_cor_pix",
                            "left_gaze_y_cor_pix",
                            "right_gaze_y_cor_pix",  
                            "gaze_x_cor_pix",  
                            "gaze_y_cor_pix",
                            # "pupil",
                            # "pupil_d",
                            # "pup_interp_pix",
                            "distance_mm",
                            "trackloss", "gaze_loss_prop", "gaze_valid_prop"
                            )
                            )
head(dta_4gazepath)


```
Check gaze data
```{r}
library(ggplot2)
#########################
# this can be slow if not sumamrised
dta_4gazepath %>%
  group_by(ssid,trialunq, screencontent_no_na)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(gaze_x_cor_pix, gaze_y_cor_pix, colour = timerezero))+
  # geom_contour()
  geom_point(alpha = .1)+
  facet_grid(~screencontent_no_na)+
  xlim(0,1920)+
  ylim(1080,0)+
  geom_hline(yintercept = 1080/2)+
    geom_vline(xintercept = 1920/2)


```




# for gaze parsing

```{r}

# Create a unique identifier for each combination of ssid and screencontent
dta_4gazepath <- dta_4gazepath %>%
  mutate(split_column = paste0(participant, "_", screencontent_no_na))

# Split the data frame into a list of data frames based on the unique combinations
unique(dta_4gazepath$split_column)
tmp_split_df <- split(dta_4gazepath, dta_4gazepath$split_column)



# Log message indicating the start of writing files for gazepath
message("Writing files for gazepath")


setwd("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/for_fix_sac")

# Iterate over the list of split data frames and write each to a CSV file
walk(names(tmp_split_df), function(tmp_splitcol) {
  write_csv(tmp_split_df[[tmp_splitcol]], paste0('gp_', tmp_splitcol, ".csv"))
})


# with bar

# library(pbapply)
# 
# # Assuming tmp_split_df is your list of data frames and names(tmp_split_df) gives their names
# pblapply(names(tmp_split_df), function(tmp_splitcol) {
#   write_csv(tmp_split_df[[tmp_splitcol]], paste0('gp_', tmp_splitcol, ".csv"))
# })
# 
# # Create a progress bar
# pb <- txtProgressBar(min = 0, max = length(names(tmp_split_df)), initial = 0, style = 3)
# 
# # Iterate over the list of split data frames
# walk(names(tmp_split_df), function(tmp_splitcol, index) {
#   # Update progress bar
#   setTxtProgressBar(pb, index)
#   
#   # Write to CSV
#   write_csv(tmp_split_df[[tmp_splitcol]], paste0('gp_', tmp_splitcol, ".csv"))
# }, index = seq_along(names(tmp_split_df)))
# 
# # Close the progress bar
# close(pb)



```

# debugging
(automated description of the problem based on context I provided)

Summary of the Problem:
You are experiencing inconsistencies when processing eye-tracking data using the gazepath method. Specifically, certain trials appear to be "flipped" or mismatched when processed together, but not when processed separately. The main issues are:

Data Flipping:

When trials 6300.jpg and 111.jpg are processed together, their visualizations match each other’s raw data, indicating a possible mix-up.
When these trials are processed separately, the visualizations match their respective raw data correctly.
Consistency Across Runs:

When running the same trials multiple times in a row, you need to ensure the patterns remain consistent.
Similarly, when running combined trials multiple times, the results should be consistent.
Order Sensitivity:

Changing the order of the trials might affect the results, indicating a possible issue with how trials are indexed or handled during processing.
Participant Specificity:

Check if the problem is specific to certain participants or if it occurs across different participants.
Problematic vs. Good Trials:

Determine if the issue only occurs with problematic trials (6300.jpg and 111.jpg) or if it also affects good trials (112.jpg).
Goals for Debugging:
Replicate Patterns Separately:

Verify if processing each trial separately produces correct and consistent results.
Check Repeatability:

Run the same trial multiple times to ensure the results are consistent each time.
Combine and Re-run Trials:

Combine multiple trials for a participant and run the processing multiple times to check for consistency.
Re-arrange and Test Order:

Change the order of trials and run the processing multiple times to see if the order affects the results.
Cross-Participant Testing:

Test the same problematic trials with data from different participants to see if the issue persists.
By following these steps, you can identify whether the issue lies in the trial handling, data indexing, or some other part of the processing pipeline. This will help you pinpoint the cause of the data flipping and ensure reliable and consistent processing of your eye-tracking data.
```{r}



tmp_140<- dta_4gazepath%>%
  subset(ssid == 140)

tmp_140


tmp_140%>%
  mutate(duplicated_event_id = duplicated(event_id) | duplicated(event_id, fromLast = TRUE),
         duplicated_time = duplicated(time) | duplicated(time, fromLast = TRUE)) %>%
  ungroup()
tmp_140%>%
  filter(!duplicated_event_id & !duplicated_time)%>%
  subset(screencontent == "stimuli")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_point()+
  facet_grid(~screencontent)


# 111
# 6300

dta_4gazepath%>%
  subset(ssid == 140)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "111.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 140; 111.jpg")




dta_4gazepath%>%
  subset(ssid == 140)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "6300.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 140; 6300.jpg")


dta_4gazepath%>%
  subset(ssid == 140)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "112.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 140; 112.jpg")





dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "111.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 215; 111.jpg")




dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "6300.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 215; 6300.jpg")


dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "112.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 215; 112.jpg")



dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "2457.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 249; 2457.jpg")

```


```{r}

dta_4gazepath%>%
  # subset(ssid == 142)%>%
  # mutate(duplicated_event_id = duplicated(event_id) | duplicated(event_id, fromLast = TRUE),
  #        duplicated_time = duplicated(time) | duplicated(time, fromLast = TRUE)) %>%
  ungroup()%>%
  arrange(time)%>%
  filter(!duplicated_event_id & !duplicated_time)%>%
  subset(screencontent == "stimuli")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_point()+
  facet_grid(~screencontent
  
  
```



dta_4gazepath%>%
  subset(ssid == 142)%>%
  arrange(time)%>%
  subset(screencontent == "stimuli")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_point()+
  facet_grid(~screencontent)






run gazepath to detect fioxationa nd saccades in gaze data


# cerate an emoty rscipt mor mark down then run the lines below
library(gazepath)
GUI() # 


run first stimuli files then fixcation files separately then rest fiules sepaartelly
note you need to close and restart gazepath after each processing

gazepath settings

left eye x coord: left_gaze_x_cor_pix
left eye y coord: left_gaze_y_cor_pix

didtance: distance (mm)

right eye x coord: right_gaze_x_cor_pix
right eye y coord: right_gaze_y_cor_pix
didtance: distance (mm)


sample rate: 150
screen resolution height (pix): 1080
screen resolution width (pix): 1920


stimuli height (px): 1080 
stimuli width (px): 1920
variables to keep: text, participant, pratice_vs_trial, stimnopath_no_na


<!-- bristol -->

USE SCREEN SIZE in mm (update accordingly)
stimuli height mm 275 
stimuli width mm 485

<!-- previous -->
<!-- stimuli height mm 300 -->
<!-- stimuli width mm 530 -->



# for gazepath run on windows this is what i needed to do
install rig
R.version
_
platform       x86_64-w64-mingw32
arch           x86_64
os             mingw32
system         x86_64, mingw32
status
major          3
minor          6.3
year           2020
month          02
day            29
svn rev        77875
language       R
version.string R version 3.6.3 (2020-02-29)
nickname       Holding the Windsock
install.packages("sp")
install.packages("jpeg")
install.packages("scales")
install.packages("zoo")
install.packages("shiny")
install.packages("gazepath_1.3.tar.gz", repos = NULL, type = "source")
library(gazepath)
GUI()
```{r}
# install from source
# download gazepath from source here: https://cran.r-project.org/src/contrib/Archive/gazepath/
# install.packages("path/to/package_name.tar.gz", repos = NULL, type = "source")
install.packages()
if (!requireNamespace("devtools", quietly = TRUE))
  install.packages("devtools")
devtools::install_github("username/repository")
install.packages("gazepath_1.3.tar.gz", repos = NULL, type = "source")
library(gazepath)
####################################
# use rig to run r version 3.6.3 to get correct results, because gazepath has not been updated for R 4+
GUI()

```




load gazepath data
```{r}
# load all fix and saccades
# Bristol data

setwd("/Users/pw22812/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/Gazepath results")

# load data
library(readr)
# load the files
tmp_filelist <- list.files(pattern = ".csv")

tmp_filelist
tmp_filelist

tmp_filelist[c(1,3,5)]
# just take the all fix sacc
dta_gp_all_fix_sacc <- rbindlist(sapply(tmp_filelist[c(1,3,5)], fread, simplify = FALSE),
                use.names = TRUE, idcol = "filename2")%>%
  janitor::clean_names()

dta_gp_all_fix_sacc
unique(dta_gp_all_fix_sacc$filename2)

colnames(dta_psypy1)

dta_psypy1$stim_iaps


# Create 'screencontent' based on 'text'

unique(dta_gp_all_fix_sacc$text)

# unique(dta_psypy1$condition)

library(dplyr)

dta_gp_all_fix_sacc <- dta_gp_all_fix_sacc %>%
  mutate(
    screencontent = case_when(
      grepl("fix", text) ~ "fixation_cross",
      grepl("stim", text) ~ "stimuli",
      grepl("rest", text) ~ "rest",
      TRUE ~ NA_character_ # Provides an NA value where none of the above conditions are met
    ),
    screencontent_no = case_when(
      screencontent == "rest" ~ 1,
      screencontent == "fixation_cross" ~ 2,
      screencontent == "stimuli" ~ 3,
      TRUE ~ NA_real_ # Ensures that a numeric NA is returned if none of the conditions match
    )
  )


# create practice vs trial
library(stringi)
# unique(dta_psypy1$stim_iaps)

# store just stimuli named
dta_gp_all_fix_sacc$stim_iaps <- paste0(sub(".*_([^_]+)\\.jpg.*", "\\1", dta_gp_all_fix_sacc$text), ".jpg")
  
dta_gp_all_fix_sacc

```

now create averages for gaze

```{r}
dta_gp_all_fix_sacc
# compute means and max fixation duration

unique(dta_gp_all_fix_sacc$screencontent)

# dta_gp_all_fix_sacc_stim<- dta_gp_all_fix_sacc%>%
#   subset(screencontent == "stimuli")%>%
#   select(-screencontent, -screencontent_no)



# are they looking at the image
# stim_aoi_vs_non_stim
# measure of eccentricity - define the centre of the screen
# entropy


range(dta_gp_all_fix_sacc$mean_x)

# Screen dimensions
screen_width <- 1920
screen_height <- 1080

# Image dimensions
image_width <- 1024
image_height <- 768

# Calculate the AOI boundaries (image centred on the screen)
aoi_x_min <- (screen_width - image_width) / 2
aoi_x_max <- aoi_x_min + image_width
aoi_y_min <- (screen_height - image_height) / 2
aoi_y_max <- aoi_y_min + image_height


ggplot()+
  geom_vline( xintercept = 0)+
  geom_vline( xintercept = 1920)+
  geom_hline( yintercept = 0)+
  geom_hline( yintercept = 1080)+
  
    geom_vline( xintercept = 448, colour = "red")+
  geom_vline( xintercept = 1472, colour = "red")+

    geom_hline( yintercept = 156, colour = "red")+
  geom_hline( yintercept = 924, colour = "red")



```
  
```{r}

dta_gp_all_fix_sacc<- dta_gp_all_fix_sacc%>%
  # image 1024, 768
  # screen 1080, 1920
  # aoi stim vs non stim
  mutate(aoi_stim_nonstim = ifelse(mean_x >= aoi_x_min & mean_x <= aoi_x_max &
                                   
                                     mean_y >= aoi_y_min & mean_y <= aoi_y_max,
                                   "stim_aoi", "nonstim_aoi"))



# eccentricity within image and whole screencontent_no_na



# Calculate the Euclidean distance from the centre for each gaze point

dta_gp_all_fix_sacc

dta_gp_all_fix_sacc<- dta_gp_all_fix_sacc %>%
  mutate(dist_from_cntr_whole_screen = sqrt((mean_x - (screen_width/2))^2 + (mean_y - (screen_height/2))^2))%>%
  group_by(participant,text, aoi_stim_nonstim)%>%
  
  mutate(dist_from_cntr_stim = 
                                 sqrt((mean_x - (screen_width / 2))^2 + (mean_y - (screen_height / 2))^2))




```

to do
Ruth will use imagej (fiji) to compute centre of mass, gray values and histograms.
we'll use centre of mass to compute a proxy of image eccentricity (centroid of entre of mass - image centroids - euclidian distance)

# consider normalising the eccentricity based on eccentricity of the image


# stim 1 = ecc 10 (more content away)
# stim 2= ecc 5 (more content in the centre)
# 
# # gaze
# gaze 1 = ecc 4
# gaze 2 = ecc 4
# 4/10 = 0.4
# 4/5 = 0.8
# 

  
https://rdrr.io/rforge/CulturalAnalytics/man/imageEntropy.html

```{r}


# https://uk.mathworks.com/help/images/ref/entropy.html
# Entropy is defined as -sum(p.*log2(p)), where p contains the normalized histogram counts returned from imhist.

```




entropy of gaze
- stationary
- transition entropy


```{r}

library(entropy)
# install.packages("GrpString")
library(GrpString)

# option 1 - grid option - devide image into a grid
# option 2 - kmean cluster

unique(dta_gp_all_fix_sacc)


dta_gp_all_fix_sacc

dta_gp_all_fix_sacc
dta_gp_all_fix_sacc%>%
  group_by(participant, text,stim_iaps)%>%
  # summarise_if(is.numeric, mean, na.rm = T)%>%
  subset(screencontent = "stimuli")%>%
  ggplot(aes(mean_x, mean_y))+
  geom_point()+
  geom_vline(xintercept = 960)+
  geom_hline(yintercept = 540)+
   geom_vline(xintercept = 448)+
   geom_vline(xintercept = 1472)+
  geom_hline(yintercept = 156)+
    geom_hline(yintercept = 924)
  

  
    
    geom_vline( xintercept = 448, colour = "red")+
  geom_vline( xintercept = 1472, colour = "red")+

    geom_hline( yintercept = 156, colour = "red")+
  geom_hline( yintercept = 924, colour = "red")




```
  
  
  
  mutate(kmeans())
  
  
  
  
  
  # compute entropy
  # shanon entropy
  mutate(entropy_clust = entropy::entropy(table(cluster_label)),
         trans_entropy = GrpString::TransEntro(cluster_label),
         trans_entropy_perclust = GrpString::TransEntropy(cluster_label),
         )%>%
  group_by(filename, cluster_across)%>%


```{r}
dta_gp_all_fix_sacc$participant

dta_gp_all_fix_sacc$ssid <- substr(dta_gp_all_fix_sacc$participant,4,6)

dta_gp_all_fix_sacc_stim<- dta_gp_all_fix_sacc %>%
  subset(screencontent== "stimuli")


dta_gp_all_fix_sacc_stim$trial


# debug
unique(dta_4gazepath$stimnopath)

dta_4gazepath%>%
      subset(ssid== 140 & stimnopath == "6300.jpg" & screencontent == "stimuli")%>%
   ggplot(aes(timerezero, gaze_y_cor_pix))+
  geom_line(aes(y = gaze_x_cor_pix))+
  geom_line()


dta_4gazepath$text
dta_4gazepath%>%
      subset(ssid== 140 & stimnopath == "2457.jpg" & screencontent == "stimuli")%>%
   ggplot(aes(timerezero, gaze_y_cor_pix))+
  geom_line(aes(y = gaze_x_cor_pix))+
  geom_line()

tmp<- dta_4gazepath%>%
      subset(ssid== 141 & stimnopath == "2457.jpg" & screencontent == "stimuli")

tmp1<- dta_4gazepath%>%
      subset(ssid== 140 & stimnopath == "111.jpg" & screencontent == "stimuli")


tmp1<- dta_4gazepath%>%
      subset(ssid== 141 & stimnopath == "111.jpg" & screencontent == "stimuli")

tmp
tmp1

```

dta_gp_all_fix_sacc%>%
      subset(ssid== 140 & stim_iaps== "6300.jpg" & screencontent == "stimuli")%>%
   ggplot(aes(start, mean_y))+
  geom_line(aes(y = mean_x))+
  geom_line()

dta_4gazepath$stimnopath
 
 
```


dta_gp_all_fix_sacc_stim_agg<- dta_gp_all_fix_sacc_stim %>%
  group_by(participant,ssid, text, trial, stim_iaps) %>%
  


  summarise(
    mean_dwell_dur = mean(duration, na.rm = TRUE),
    mean_fix_dur = mean(duration[value == "f"], na.rm = TRUE),
    mean_sac_dur = mean(duration[value == "s"], na.rm = TRUE),
    sum_dwell_dur = sum(duration, na.rm = TRUE),
    sum_fix_dur = sum(duration[value == "f"], na.rm = TRUE),
    sum_sac_dur = sum(duration[value == "s"], na.rm = TRUE),
    mean_rms = mean(rms, na.rm = TRUE),
    mean_po_gsd = mean(po_gsd_sac_amp[value == "f"], na.rm = TRUE),
    mean_sac_amp = mean(po_gsd_sac_amp[value == "s"], na.rm = TRUE),
    count_fix = sum(value == "f"),
    count_sacc = sum(value == "s")
    # .groups = "drop" # This explicitly drops the grouping instead of keeping it
  )%>%

  # Optionally, ungroup if you want to remove the grouping structure
  ungroup()
```


```{r}
dta_gp_all_fix_sacc_stim_agg%>%
      # subset(ssid!= 140)%>%
  group_by(participant,ssid)%>%

  summarise_if(is.numeric, max, na.rm = T)%>%
  ggplot(aes( sum_dwell_dur,participant))+
  # geom_point()+
  geom_text(aes(label = ssid))



```

```{r}
dta_gp_all_fix_sacc_stim_agg%>%
      subset(ssid== 140)%>%
  group_by(participant,stim_iaps)%>%

  summarise_if(is.numeric, max, na.rm = T)%>%
  ggplot(aes( sum_dwell_dur,stim_iaps))+
  # geom_point()+
  geom_text(aes(label = stim_iaps))


```


dta_gp_all_fix_sacc_stim_agg<- dta_gp_all_fix_sacc_stim_agg%>%
      subset(ssid== 140)




```
  

# add trackloss

colnames(dta_4gazepath)
dta_4gazepath$split_column
dta_4gazepath$screencontent_no_na

dta_4gazepath$stimnopath
trackloss<- dta_4gazepath%>%
  select(participant, screencontent_no_na,text, gaze_valid_prop)%>%
  subset(screencontent_no_na == "stimuli")%>%
  select(-screencontent_no_na)%>%
  group_by(participant, text) %>%
  summarise_at(c("gaze_valid_prop"), mean, na.rm = T)%>%
  mutate(gaze_valid_prop_ppt = mean(gaze_valid_prop, na.rm = T))


dta_gp_all_fix_sacc_stim_agg<- left_join(dta_gp_all_fix_sacc_stim_agg, 
                                                 trackloss, by = c("participant", "text"))
```


to merge

```{r}

dta_gp_all_fix_sacc_stim_agg

```