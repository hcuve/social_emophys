---
title: "eyetracking pre-procesing - social vs non social modualtion of emotion response and physilogy"
author: "Helio"
date: "2024-03-07"
output: html_document
---



# Overview 
In this file I aim to process all the gaze data, essentially read, clean and combines multiple files with gaze data and their metadata

# Conventions
For data: dta_
Temporary files: tmp_
Statistical summaries: sum_
Models (such as lm models): mod_
Custom functions: fn_
Plots and visualization: plt_
Lookup and referecne tables: lkp_
Results and Analysis: rlt_
Consistency and accuracy checks: chk_

4. Check gaze data



Set-up: where I load libraries and create objects for later use (such as color schemes etc).


version of R

R version 4.4.0 (2024-04-24) -- "Puppy Cup"
Copyright (C) 2024 The R Foundation for Statistical Computing
Platform: x86_64-apple-darwin20

```{r setup, include=FALSE}
# store date
current_date<- Sys.Date()

# libraries
require(tidyverse)
require(data.table)
require(readr)

# for reading hdf5 files
# if (!requireNamespace("BiocManager", quietly = TRUE))
# install.packages("BiocManager")
# BiocManager::install(version = "3.19")
# 
# BiocManager::install("rhdf5")
library(rhdf5)




```

Data Import / Cleaning: where datasets are imported and cleaned.
```{r}

# setwd("/Users/pw22812/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking")

# get hdf files in 
hdf5_file_path<-"~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking"
  
# set working directory
setwd(hdf5_file_path)

# 


```


File Listing: It lists all HDF5 files in the given directory (hdf5_file_path).

File Check: If no HDF5 files are found, it returns a message indicating this.

Loop Through Files: For each HDF5 file:

File Information: It prints a message indicating the file being processed.
Extract Events: Reads the 'MessageEvent' data from the file.
Filter Events: Keeps only the relevant events (tStart, tEnd, and those with category "VALIDATION").
Extract Eye Tracking Data: Reads the 'GazepointSampleEvent' data.
Extract Subject ID: Extracts the subject ID from the file name.
Event Processing:
Filters events to keep only start and end messages.
Creates start and end time references.
Labels events with screen content (fixation or stimuli) and trial type (practice or trial).
Extracts the stimulus file name from the event text.
Data Preparation:
Converts raw eye-tracking data to a double format.
Subsets eye-tracking data based on event start and end times.
Adds metadata (screen content, trial type, stimulus path, subject ID) to eye-tracking data.
Binds the trial data to a dataframe.
Sorting and Saving:
Sorts the dataframe by time.
Saves the processed eye-tracking data to a CSV file named with the subject ID and the current date.
Saves the calibration events to a separate CSV file.
Completion Message: Prints a message indicating that processing is completed.

Return Dataframe: Returns the dataframe with the processed data.
```{r}

# creating the fucntion
fn_gp.extractor = function(hdf5_file_path) {
  
  hdf_files_list = list.files(hdf5_file_path, pattern = "\\.hdf5$")
  
  if (length(hdf_files_list) == 0){
    
    return(message('No HDF5 files found in the directory provided.'))
  }
  hdf_files_list1 = hdf_files_list[40]
  
  # pb <- txtProgressBar(min = 0, max = length(hdf_files_list), style = 3)

  for (f in 1:length(hdf_files_list)) {
    # f = 1
    message(sprintf("Extracting file %i / %i - %s", f, length(hdf_files_list), hdf_files_list[f]))
    
    #note this sometimes fails because e are using a notebook 
    # Extract Events from hdf5, in that case run it from command
    tmp.events =h5read(hdf_files_list[f], '/data_collection/events/experiment/MessageEvent')
    
    # tmp.events1 =h5read(hdf_files_list[41], '/data_collection/events/experiment/MessageEvent')

    # tmp.events_tmp<- bind_rows(tmp.events, tmp.events1)
    # check tstop or tend
    tmp.events$keep_drop<- if_else(grepl(c('tStart'), tmp.events$text), "keep",
                                   if_else(grepl(c('tEnd'), tmp.events$text), "keep",
                                            if_else(tmp.events$category == "VALIDATION", "keep",
                                           "drop")))
    
    tmp.events<- subset(tmp.events, keep_drop == "keep")
  
  
    # load the eye tracking data
    tmp.eyetr  = h5read(hdf_files_list[f], '/data_collection/events/eyetracker/GazepointSampleEvent') # note this is
    # 
    # tmp.eyetr1  = h5read(hdf_files_list[41], '/data_collection/events/eyetracker/GazepointSampleEvent') # note this is
    #  tmp.eyetr_tmp<- bind_rows(tmp.eyetr, tmp.eyetr1)
    #  
    #  tmp.events<- tmp.events_tmp
    # tmp.eyetr<- tmp.eyetr_tmp
    
    # updated to GazepointSampleEvent whereas before it was BinocularEyeSampleEvent
    
f = 40
    # Get subejct id from Events
    ssid = sub("_.*", "", hdf_files_list[f])
      # substr(hdf_files_list[f], 1,3)
    # update the string before the data
    date = gsub('^.*Interostudy_\\s*|\\s*.hdf5*$', '', hdf_files_list[f])
    
  
    session = unique(tmp.events$session_id)

    
    # Create DF for trials data
    tmp.df = data.frame(matrix(ncol = ncol(tmp.eyetr)))
    names(tmp.df) = names(tmp.eyetr)
    colnames(tmp.df)
    
    # Prepare Events, keep only start/end messages
    phrases = c('tStart', 'tEnd')

    
    # unique(tmp.events$category)
    tmp.events_calib = subset(tmp.events, category == "VALIDATION")
    
    tmp.events = subset(tmp.events, grepl(paste(phrases, collapse = "|"), tmp.events$text))
# tmp.events    
    # we should have a total of XX stimuli multiplied by 4 (start and t end for stim and fix) 
    # 4 pratice + 48 trials = 52
    # 52*4 = we should should 208 rows
    # Create start/end references
    tmp.events$t_start   = NA
    tmp.events$t_end     = NA
    
    # Trial number extraction 
    tmp.events$t_no      = NA
    
    # Space for subject id
    tmp.df$ssid         = NA
    tmp.df$text<-NA
    
    for (l in 1:nrow(tmp.events)) {
      
      message(sprintf("Grabing start messages %s", tmp.events$text[l]))
      
      if ((grepl('tStart', tmp.events$text[l])) == TRUE) {
        tmp.events$t_start[l] = tmp.events$time[l]
        
        if ((grepl('tEnd', tmp.events$text[l+1])) == TRUE){
          tmp.events$t_end[l] = tmp.events$time[l+1]
        }
        
        else {
          message('trial start/end structure not valid')
        }
      }
      
    }
    
    message(sprintf("done grabbing messages"))
    # readline(prompt="Press [enter] to continue")
    
     message(sprintf("making screencontent"))
     # unique(tmp.events$text)
    tmp.events$screencontent <- if_else(grepl('fix', tmp.events$text), 'fixation',
                                       if_else(grepl('stim', tmp.events$text), 'stimuli', NA))
    
    
    # first let's do condition
    # update the names
    tmp.events$pratice_vs_trial<- if_else(grepl('Example', tmp.events$text), 'Pratice',
                                   if_else(grepl('IAPS', tmp.events$text), 'Trial', NA))
    
 
    # store stim code here -0 we need the content between "_" and ".jpg
    tmp.events$stimnopath<-   paste0(sub(".*_(.*?)\\.jpg.*", "\\1", tmp.events$text), ".jpg")
      
      
    
    # tmp.events$emotion_yes_no_new<- 
    
    tmp.events1 = subset(tmp.events, grepl('tStart',tmp.events$text))
 

    tmp.df$screencontent<- NA
    tmp.df$pratice_vs_trial <- NA
    # tmp.df$isfakeOrReal <- NULL
    tmp.df$stimnopath <- NA
    
    # e=10
        message(sprintf("subsetting eyetracking data"))
    
        tmp.events1$ssid<- ssid
        
        # why?
tmp.eyetr<-tmp.eyetr%>%
  mutate_if(is.raw, as.double)

for(e in 1:nrow(tmp.events1)) {
      # e = 1
      # Subset the EyeTracking data based on start/end
      tmp.raw.trial = subset(tmp.eyetr, 
                             tmp.eyetr$time >= tmp.events1$t_start[e] & tmp.eyetr$time <= tmp.events1$t_end [e]+.5)
      
      # tmp.raw.trial$tNo = tmp.events1$tNo[e]
      # tmp.events1$tNo<-NULL
      
      tmp.raw.trial$screencontent = tmp.events1$screencontent[e]
      tmp.raw.trial$pratice_vs_trial = tmp.events1$pratice_vs_trial[e]
      # tmp.raw.trial$isfakeOrReal = tmp.events1$isfakeOrReal[e]
      tmp.raw.trial$stimnopath = tmp.events1$stimnopath[e]
      # tmp.raw.trial$stim = tmp.events1$[e]
      tmp.raw.trial$ssid = ssid
      tmp.raw.trial$text = tmp.events1$text[e]
       message(sprintf("binding tmp.df"))
       
      tmp.df<- rbind(tmp.raw.trial,tmp.df)

}

        
     message(sprintf("done binding"))
    
    # Add ssid
    # tmp.df$ssID = ssid[e]
    tmp.df<- tmp.df%>%
      arrange(time)
    
     ###########################
    # Save file
    
    name = sprintf("%s_",ssid)
    message(sprintf("saving data"))
    write.csv(tmp.df, paste0(name,Sys.Date(), paste0("_gp_data.csv")))#
    # write.csv(tmp.df, paste0(name,Sys.Date(), paste0(".csv")))#
    
    ###########################
    # write calibration cali
    name2 = sprintf("%s_", ssid)
    write.csv(tmp.events_calib, paste0(name2,Sys.Date(), paste0("_gp_data_cali.csv")))#
      
    #   sprintf("ss%s_GPdata_cali", ssid)
    # write.csv(tmp.events_calib, paste0(name2,Sys.Date(), paste0(".csv")))#
    
  }
  

  message("Processing Completed.")
  tmp.df
  # close(pb)
}

# tmp.df%>%
#   group_by(text)%>%
#   mutate(diff_time = time-lag(time))%>%
#   mutate(cum_diff = sum(abs(diff_time), na.rm = T))%>%
#   ggplot(aes(cum_diff))+
#   geom_histogram()+
#   facet_grid(~screencontent)
# 
# table(is.na(tmp.df$screencontent))


```

run the fn_gp.extractor

140 had to be re-run separately due to slit session

```{r }

# not this throws an error on problematic participants
tmp_full<- fn_gp.extractor(hdf5_file_path)




tmp_test<-fn_gp.extractor(hdf_files_list[40])

tmp_full

```




Now some basic cleaning 

```{r, cleaning}
# setwd("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/raw")

# reads all individual gaze exported files into one big file

library(readr)
# colnames(X101_2024_03_07_gp_data)


read_plus <- function(flnm) {
  data.table::fread(flnm, select = c( "ssid", "session_id","event_id", "time", "left_gaze_x", "left_gaze_y","right_gaze_x", "right_gaze_y","left_pupil_measure1",
                                     "right_pupil_measure1",
                                     "left_pupil_measure2",
                                     "right_pupil_measure2",
                                     "status", 
                                     "screencontent",
                                     "pratice_vs_trial",
                                     "stimnopath",
                                     
                                     "text")) %>% 
    mutate(filename = flnm)
}


# read all clean data 

dta_eytr <-
  list.files(pattern = "*data.csv", 
             full.names = T) %>% 
  map_df(~read_plus(.))%>%
  janitor::clean_names()%>%
  subset(!is.na(ssid))

# three digits?
# Regular expression to capture the pattern before "_" and after "./"
pattern <- "\\./([0-9]+)_.*"

# Extract the pattern
unique(dta_eytr$stimnopath)

length(unique(dta_eytr$ssid))
length(unique(sub(pattern, "\\1", dta_eytr$filename)))

dta_eytr$participant<-  sub(pattern, "\\1", dta_eytr$filename)
# dta_eytr$participant<-  dta_eytr$ssid





dta_eyetrack

unique(dta_eytr$screencontent)

dta_eytr$screencontent_no_na <- if_else(is.na(dta_eytr$screencontent), "rest", dta_eytr$screencontent)

dta_eytr$stimnopath_no_na <- if_else(is.na(dta_eytr$stimnopath), "rest", 
                                   if_else(dta_eytr$stimnopath == "tStart_rest1_cross", "rest",       
                                           dta_eytr$stimnopath))

unique(dta_eytr$text)
  
```




#####################################################################################
# gp preprocessing funtion, checks for losses, averages gaze, pupil and pixelate
#####################################################################################

```{r, gppreprocessing}

unique(dta_eytr$status)

fn_gp_preprocessing = function(dta_eytr) {
  
  message(sprintf("step1 left gaze validity"))
  
  # transform invalid gaze into NA based on validity codes
  # to do: link the conventions file
  
#   status - https://psychopy.org/api/iohub/device/eyetracker_interface/GazePoint_Implementation_Notes.html
# Indicates if eye sample contains ‘valid’ data for left and right eyes. 
  # 0 = Eye sample is OK. 2 = Right eye data is likely invalid. 20 = Left #eye data is likely invalid. 22 = Eye sample is likely invalid.
  dta_eytr$left_gaze_x_cor<- if_else(dta_eytr$status != '20', dta_eytr$left_gaze_x, NA)
  dta_eytr$left_gaze_x_cor<- if_else(dta_eytr$status != '22', dta_eytr$left_gaze_x_cor, NA)
  dta_eytr$left_gaze_y_cor<- if_else(dta_eytr$status != '20', dta_eytr$left_gaze_y, NA)
  dta_eytr$left_gaze_y_cor<- if_else(dta_eytr$status != '22', dta_eytr$left_gaze_y_cor, NA)
  
  message(sprintf("step2 right gaze validity"))
  
  dta_eytr$right_gaze_x_cor<- if_else(dta_eytr$status != '2', dta_eytr$right_gaze_x, NA)
  #
  dta_eytr$right_gaze_x_cor<- if_else(dta_eytr$status != '22', dta_eytr$right_gaze_x_cor, NA)
  dta_eytr$right_gaze_y_cor<- if_else(dta_eytr$status != '2', dta_eytr$right_gaze_y, NA)
  dta_eytr$right_gaze_y_cor<- if_else(dta_eytr$status != '22', dta_eytr$right_gaze_y_cor, NA)

  # pupil validity
  
  message(sprintf("step3 pupil validity"))
  # pupil pixels
  dta_eytr$left_pupil_measure1<- if_else(dta_eytr$status != '20', dta_eytr$left_pupil_measure1, NA)
  dta_eytr$left_pupil_measure1<- if_else(dta_eytr$status != '22', dta_eytr$left_pupil_measure1, NA)
  
  dta_eytr$right_pupil_measure1<- if_else(dta_eytr$status != '2', dta_eytr$right_pupil_measure1, NA)
  dta_eytr$right_pupil_measure1<- if_else(dta_eytr$status != '22', dta_eytr$right_pupil_measure1, NA)
  table(is.na(dta_eytr$right_pupil_measure1))
  
  # pupil diameter
  
   dta_eytr$left_pupil_measure2<- if_else(dta_eytr$status != '20', dta_eytr$left_pupil_measure2, NA)
  dta_eytr$left_pupil_measure2<- if_else(dta_eytr$status != '22', dta_eytr$left_pupil_measure2, NA)
  
  dta_eytr$right_pupil_measure2<- if_else(dta_eytr$status != '2', dta_eytr$right_pupil_measure2, NA)
  dta_eytr$right_pupil_measure2<- if_else(dta_eytr$status != '22', dta_eytr$right_pupil_measure2, NA)
  table(is.na(dta_eytr$right_pupil_measure2))
  
  # check gazepoint out of bounds and repixelate 
  
  # screen=1, size=array([1920, 1080]) # update here accordingly
  
  # (1920/2 = 960 by 1080/2 = 540 add half to normalised coordinates from psychopy)
  # update according to setup
  
  message(sprintf("step 4 cutting off screen in points and repixelate"))
  
  dta_eytr$left_gaze_x_cor<- if_else(dta_eytr$left_gaze_x_cor >= -960 & dta_eytr$left_gaze_x_cor <= 960, dta_eytr$left_gaze_x_cor, NA)
  dta_eytr$right_gaze_x_cor<- if_else(dta_eytr$right_gaze_x_cor >= -960 & dta_eytr$right_gaze_x_cor <= 960, dta_eytr$right_gaze_x_cor, NA)
  
  dta_eytr$left_gaze_y_cor<- if_else(dta_eytr$left_gaze_y_cor >= -540 & dta_eytr$left_gaze_y_cor <= 540, dta_eytr$left_gaze_y_cor, NA)
  dta_eytr$right_gaze_y_cor<- if_else(dta_eytr$right_gaze_y_cor >= -540 & dta_eytr$right_gaze_y_cor <= 540, dta_eytr$right_gaze_y_cor, NA)
  
  dta_eytr$left_gaze_x_cor_pix<- dta_eytr$left_gaze_x_cor+960
  dta_eytr$right_gaze_x_cor_pix<- dta_eytr$right_gaze_x_cor+960
  
  dta_eytr$left_gaze_y_cor_pix<- dta_eytr$left_gaze_y_cor+540
  dta_eytr$right_gaze_y_cor_pix<- dta_eytr$right_gaze_y_cor+540
  
  # is left or right an NA
  
  dta_eytr$left_na<- is.na(dta_eytr$left_gaze_x_cor) 
  dta_eytr$right_na<- is.na(dta_eytr$right_gaze_x_cor)
  dta_eytr$both_na<- if_else(dta_eytr$left_na == TRUE & dta_eytr$right_na == TRUE, TRUE, FALSE)
  
  message(sprintf("step5 gaze x  means"))
  # create gaze means betwenn left and right eye
  
  dta_eytr$gaze_x_cor<-if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_gaze_x_cor,
                              if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_gaze_x_cor,
                                      ((dta_eytr$left_gaze_x_cor + dta_eytr$right_gaze_x_cor)/2)))
  message(sprintf("step6 gaze y means"))
  
  dta_eytr$gaze_y_cor<-if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_gaze_y_cor,
                              if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_gaze_y_cor,
                                      ((dta_eytr$left_gaze_y_cor + dta_eytr$right_gaze_y_cor)/2)))
  
  message(sprintf("step6 repixelate gaze means"))
  
  dta_eytr$gaze_x_cor_pix<- dta_eytr$gaze_x_cor + 960
  # min(dta_eytr$gaze_x_cor_pix, na.rm = TRUE)
  
  dta_eytr$gaze_y_cor_pix<- dta_eytr$gaze_y_cor+540
  # min(dta_eytr$gaze_y_cor_pix, na.rm = TRUE)
  
  # clean_pupil
  
  message(sprintf("cleaning pupil"))
  
  # max(dta_eytr$left_pupil_measure1)
  
  dta_eytr$pupil<- if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_pupil_measure1,
                          if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_pupil_measure1,
                                  ((dta_eytr$left_pupil_measure1 + dta_eytr$right_pupil_measure1)/2)))
  
  
  # diameter
  dta_eytr$pupil_d<- if_else(dta_eytr$left_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$right_pupil_measure2,
                          if_else(dta_eytr$right_na == TRUE & dta_eytr$both_na == FALSE, dta_eytr$left_pupil_measure2,
                                  ((dta_eytr$left_pupil_measure2 + dta_eytr$right_pupil_measure2)/2)))
  
  
  # dta_eytr$trackloss<- if_else(dta_eytr$status > 0, TRUE, FALSE)
  dta_eytr$trialunq<- paste0(dta_eytr$pratice_vs_trial,"_",paste0(dta_eytr$screencontent,"_", paste0(dta_eytr$stimnopath_no_na)))
  dta_eytr$distance_mm = 600
  
  # min(dta_eytr$pupil, na.rm = TRUE)
  # max(dta_eytr$pupil, na.rm = TRUE)
  # colnames(dta_eytr)
  dta_eytr<- dta_eytr%>%
    # group_by(ssid)
    arrange(ssid,time)
}


# unique(paste0(dta_eytr$pratice_vs_trial,"_",paste0(dta_eytr$screencontent,"_", paste0(dta_eytr$stimnopath_no_na))))

# paste0(dta_eytr$pratice_vs_trial,"_",paste0(dta_eytr$screencontent,"_", paste0(dta_eytr$stim)))


# trialunq is wrong
```

repixelated and minimally processed (e.g. deleting invalid samples), merging left and right eye
```{r}
rm(gp_preprocessing)
dta_eytr_rpx<- fn_gp_preprocessing(dta_eytr)


colnames(dta_eytr_rpx) 
 
options(scipen = 999)
options(scipen = 999)
range(dta_eytr_rpx$pupil, na.rm = TRUE)
range(dta_eytr_rpx$pupil_d, na.rm = TRUE)
range(dta_eytr_rpx$gaze_y_cor_pix, na.rm = TRUE)
range(dta_eytr_rpx$gaze_x_cor_pix, na.rm = TRUE) 

# split and export per participant

colnames(dta_eytr_rpx)

unique(dta_eytr_rpx$stimnopath)

dta_eytr_rpx<- dta_eytr_rpx%>%
  group_by(participant)%>%
  arrange(time)


# Split the dataframe based on 'group_column'
list_of_dfs <- split(dta_eytr_rpx, dta_eytr_rpx$participant)

colnames(dta_eytr_rpx)

# Iterate over the list to write each dataframe to a CSV file
lapply(names(list_of_dfs), function(x) {
  csv_filename <- paste0(x, "_dta_eytr_rpx.csv")
  write.csv(list_of_dfs[[x]], csv_filename, row.names = FALSE)
})

```
quick checks
```{r}
dta_eytr_rpx%>%
  group_by(participant)%>%
  arrange(time)%>%
  
  mutate(tmp_group = paste0(stimnopath_no_na,screencontent_no_na))%>%
  group_by(tmp_group)%>%
 
  subset(participant == 117& screencontent_no_na != "rest")%>%
   mutate(time_rezero = time - first(time)) %>%
  ggplot(aes(time_rezero, gaze_x_cor_pix))+
    geom_line()+
    geom_line(aes(y = gaze_y_cor_pix), colour = "blue")+
  facet_grid(~screencontent_no_na)+
  geom_vline(xintercept = 6.6, linetype = "dashed", colour ="red")+
  ylab("gaze coordinates")



dta_eytr_rpx%>%
  group_by(participant)%>%
  arrange(time)%>%
  
  mutate(tmp_group = paste0(stimnopath_no_na,screencontent_no_na))%>%
  group_by(tmp_group)%>%
 
  subset(participant == 117& screencontent_no_na != "rest")%>%
   mutate(time_rezero = time - first(time)) %>%
  ggplot(aes(time_rezero, pupil))+
    geom_smooth(aes(group = stimnopath_no_na), se = F)+
    # geom_line(aes(y = gaze_y_cor_pix), colour = "blue")+
  facet_grid(~screencontent_no_na)+
  geom_vline(xintercept = 6.6, linetype = "dashed", colour ="red")
  ylab("gaze coordinates")



```



######################
# rezeroing times by trial, by participants


```{r}
dta_eytr_rpx
# create start at every screen content
# Preview unique screen contents and dataset structure
print(unique(dta_eytr_rpx$text))
print(colnames(dta_eytr_rpx))


unique(dta_eytr_rpx$trialunq)
unique(dta_eytr_rpx$pratice_vs_trial)
unique(dta_eytr_rpx$screencontent)
unique(dta_eytr_rpx$screencontent_no_na)
dta_eytr_rpx$trialunq
# only run this is the previous processing code is not fixed where trialunq includes pratice vs trial


dta_eytr_rpx$pratice_vs_trial<- ifelse(is.na(dta_eytr_rpx$pratice_vs_trial), "rest", dta_eytr_rpx$pratice_vs_trial)


dta_eytr_rpx$trialunq<- paste0(dta_eytr_rpx$pratice_vs_trial,"_",paste0(dta_eytr_rpx$screencontent,"_", paste0(dta_eytr_rpx$stimnopath_no_na)))

table(is.na(dta_eytr_rpx$trialunq))

unique(dta_eytr_rpx$trialunq)
unique(dta_eytr_rpx$text)


dta_eytr_rpx <- dta_eytr_rpx %>%
  arrange(participant, time) %>%
  group_by(ssid, screencontent_no_na) %>%
  mutate(is_firststart = !duplicated(trialunq)) %>%
  ungroup()# Use '!' to correctly identify the first start

# Preview the data to ensure the above operation worked as intended
print(head(dta_eytr_rpx))

# Create a zero-time column where the first occurrence of each trial is marked with its time, others as NA
dta_eytr_rpx <- dta_eytr_rpx %>%
  mutate(zero = if_else(is_firststart, time, NA_real_)) # Use NA_real_ for consistency in numeric columns

# Propagate the zero times down each group to fill in the NAs
dta_eytr_rpx <- dta_eytr_rpx %>%
  group_by(ssid, screencontent_no_na, trialunq) %>%
  fill(zero, .direction = "down")%>% # Explicitly mention direction for clarity
  ungroup()

# Calculate the time relative to zero for each trial
dta_eytr_rpx <- dta_eytr_rpx %>%
  mutate(timerezero = time - zero)

# Arrange by time for final organization, if necessary
dta_eytr_rpx <- dta_eytr_rpx %>%
  arrange(participant, time)

dta_eytr_rpx140<- dta_eytr_rpx%>%
  subset(ssid == 140)


dta_eytr_rpx<- dta_eytr_rpx%>%
  subset(ssid != 140)

unique(dta_eytr_rpx140$screencontent)
unique(dta_eytr_rpx140$screencontent_no_na)

dta_eytr_rpx140<- dta_eytr_rpx140%>%
  mutate(rest_1_trial_2 = if_else(dta_eytr_rpx140$screencontent_no_na == "rest",1,2 ))%>%
  arrange(rest_1_trial_2, time)

# > 1705.112-1705.105
# [1] 0.007
# [1] 2
# > 1/150
# [1] 0.006666667

dta_eytr_rpx<- bind_rows(dta_eytr_rpx,dta_eytr_rpx140)


```

# Optionally, print unique zero times to verify the operation
print(unique(dta_eytr_rpx$zero))

# Results stored in 'dta_gaze_clean' with 'timerezero' reflecting time since trial start



# create a new time rezero where before stim start, time is negative
```{r}

dta_eytr_rpx$timerezero

dta_eytr_rpx<- dta_eytr_rpx %>%
  group_by(participant, stimnopath_no_na) %>%
  arrange(participant, time) %>%
  mutate(general_time = row_number() - 1) %>% # This assumes your data starts from 0 and increments
  group_by(ssid, stimnopath_no_na, screencontent_no_na, .add = TRUE) %>%
  mutate(
    backward_time = max(timerezero) - timerezero, # Calculate backward time for fixation
    time_backward = case_when(
      screencontent_no_na == "stimuli" ~ timerezero, # Use timezero directly for forward time in stimuli
      screencontent_no_na == "fixation" ~ -backward_time, # Use negative backward time for fixation
      TRUE ~ NA_real_ # Fallback case
    )
  ) %>%
  ungroup()



dta_eytr_rpx%>%
subset(ssid == 116 & screencontent_no_na!= "rest") %>%
ggplot( aes(time_backward, pupil ))+
  geom_smooth(aes(group = stimnopath_no_na), se = F, size = .1)+
  geom_vline(xintercept = 0, linetype = "dashed")
    # facet_grid(~screencontent_no_na)
  



  

```



# Filter out rows where either event_id or time is duplicated within each ssid

```{r eval=FALSE, include=FALSE}

dta_eytr_rpx <- dta_eytr_rpx %>%
  group_by(participant) %>%
  mutate(duplicated_event_id = duplicated(event_id) | duplicated(event_id, fromLast = TRUE),
         duplicated_time = duplicated(time) | duplicated(time, fromLast = TRUE)) %>%
  ungroup()

table(dta_eytr_rpx$duplicated_event_id)



dta_eytr_rpx_nodup <- dta_eytr_rpx %>%
  filter(!duplicated_event_id & !duplicated_time)


tmp_test<-  dta_eytr_rpx %>%
  subset(duplicated_event_id & duplicated_time)
nrow(dta_eytr_rpx_nodup )/nrow(dta_eytr_rpx)         
# 0.8980762

# don'\t subset as this sems to happen at the end or start of screens and mighht cutout our isfirst start -==- TRUE
```



select variables for gazepath
```{r}
dta_eytr_rpx$ssid
dta_eytr_rpx$participant
dta_eytr_rpx$subject <- dta_eytr_rpx$ssid


# correct the isues with trial unique indicator

  dta_eytr_rpx$trialunq<- paste0(dta_eytr_rpx$pratice_vs_trial,"_",paste0(dta_eytr_rpx$screencontent,"_", paste0(dta_eytr_rpx$stimnopath_no_na)))

unique(  dta_eytr_rpx$trialunq) #expect 129 (64 trials * 2 (fixationa trial) + 1 rest)
# 
dta_eytr_rpx<- dta_eytr_rpx%>%
 mutate(rest_1_trial_2 = if_else(screencontent_no_na == "rest",1,2 ))%>% # we need to do this because of 140 time issues
group_by(participant)%>%
  arrange(rest_1_trial_2,time)

dta_eytr_rpx%>%
  subset(participant==140)


dta_eytr_rpx$distance_mm <- 650



dta_eytr_rpx$trackloss<- if_else(is.na(dta_eytr_rpx$gaze_x_cor_pix) == TRUE, 0, 
                         if_else(is.na(dta_eytr_rpx$gaze_y_cor_pix) == TRUE, 0, 1))

unique(dta_eytr_rpx$trackloss)

# compute proportion of lost data

# dta_gaze_clean_10s_nodup$trialunq #problematic

dta_eytr_rpx <- dta_eytr_rpx %>%
  group_by(participant, text)%>%
  mutate(gaze_valid_prop = sum(trackloss)/n())%>%
  mutate(gaze_loss_prop = 1 - gaze_valid_prop)%>%
  group_by(participant)%>%
  arrange(time)%>%
  ungroup()


# check to see this is right

dta_eytr_rpx%>%
  ggplot(aes(gaze_loss_prop))+
  geom_histogram()

dta_eytr_rpx%>%
  ggplot(aes(gaze_valid_prop))+
  geom_histogram()
```


select for gazepath
```{r}
dta_eytr_rpx$filename


dta_eytr_rpx$trialunq

dta_4gazepath<- select(dta_eytr_rpx, 
                                      c("participant", "session_id", "event_id", "ssid", 
                                        "text","trialunq","screencontent",
                                        "screencontent_no_na","pratice_vs_trial",                           "stimnopath",
                                        "stimnopath_no_na",
                            "time", "timerezero","time_backward",
                            "status",
                            "filename",
                            "left_gaze_x_cor_pix",
                            "right_gaze_x_cor_pix",
                            "left_gaze_y_cor_pix",
                            "right_gaze_y_cor_pix",  
                            "gaze_x_cor_pix",  
                            "gaze_y_cor_pix",
                            # "pupil",
                            # "pupil_d",
                            # "pup_interp_pix",
                            "distance_mm",
                            "trackloss", "gaze_loss_prop", "gaze_valid_prop"
                            )
                            )
head(dta_4gazepath)


```
Check gaze data
```{r}
library(ggplot2)
#########################
# this can be slow if not sumamrised
dta_4gazepath %>%
  group_by(ssid,trialunq, screencontent_no_na)%>%
  summarise_if(is.numeric, mean, na.rm = T)%>%
  ggplot(aes(gaze_x_cor_pix, gaze_y_cor_pix, colour = timerezero))+
  # geom_contour()
  geom_point(alpha = .1)+
  facet_grid(~screencontent_no_na)+
  xlim(0,1920)+
  ylim(1080,0)+
  geom_hline(yintercept = 1080/2)+
    geom_vline(xintercept = 1920/2)


```




# for gaze parsing

```{r}

# remove event id duplicates - this probably needs to be done earlier

dta_4gazepath


dta_4gazepath<- dta_4gazepath%>%
  group_by(participant,text)%>%
  arrange(time)%>%
  # mutate(time1 = time, time2 = lead(time))%>%
   # mutate(time_diff = time1 -time2)%>%
  
   mutate(event_diff = event_id -lead(event_id))%>%
 mutate(
        unk_sample_ev = abs(event_diff)< 2,
        )

dta_4gazepath1<- dta_4gazepath%>%
  subset(event_diff<2)

unique(dta_4gazepath1$ssid)


dta_4gazepath1<- dta_4gazepath1%>%
  arrange(ssid, trial_no, timerezero)
```


here recreate the matrix, as somewhere in the process the daatframe becomes weird (e.g. column as lists)
```{r}
colnames(dta_4gazepath1)

dta_4gazepath1 <- dta_4gazepath1 %>%
  mutate(split_column = paste0("gp_", ssid, "_",paste0(screencontent_no_na)))

dta_4gazepath1$split_column

# Define the column types
column_types <- list(
  participant = "factor",
  session_id = "factor",
  event_id = "factor",
  ssid = "factor",
  text = "character",
  trialunq = "factor",
  screencontent = "character",
  screencontent_no_na = "character",
  pratice_vs_trial = "factor",
  stimnopath = "factor",
  stimnopath_no_na = "factor",
  time = "numeric",
  timerezero = "numeric",
  time_backward = "numeric",
  status = "factor",
  filename = "character",
  left_gaze_x_cor_pix = "numeric",
  right_gaze_x_cor_pix = "numeric",
  left_gaze_y_cor_pix = "numeric",
  right_gaze_y_cor_pix = "numeric",
  gaze_x_cor_pix = "numeric",
  gaze_y_cor_pix = "numeric",
  distance_mm = "numeric",
  trackloss = "numeric",
  gaze_loss_prop = "numeric",
  gaze_valid_prop = "numeric",
  split_column = "factor",
  trial_no = "factor",
  trial_no_gpid_stim = "factor",
  event_diff = "numeric",
  unk_sample_ev = "character"
)

# Convert columns to appropriate types
for (col in names(column_types)) {
  type <- column_types[[col]]
  if (type == "factor") {
    dta_4gazepath1[[col]] <- as.factor(dta_4gazepath1[[col]])
  } else if (type == "character") {
    dta_4gazepath1[[col]] <- as.character(dta_4gazepath1[[col]])
  } else if (type == "numeric") {
    dta_4gazepath1[[col]] <- as.numeric(dta_4gazepath1[[col]])
  }
}





```

# Split the data frame into a list of data frames based on the unique combinations

```{r}

dta_4gazepath_stim<- dta_4gazepath1%>%
  subset(screencontent_no_na == "stimuli")

dta_4gazepath_fix<- dta_4gazepath1%>%
  subset(screencontent_no_na == "fixation")

dta_4gazepath_rest<- dta_4gazepath1%>%
  subset(screencontent_no_na == "rest")
unique(dta_4gazepath_rest$stimnopath_no_na)



saveRDS(dta_4gazepath_stim, "dta_4gazepath_stim.rds")
saveRDS(dta_4gazepath_fix, "dta_4gazepath_fix.rds")
saveRDS(dta_4gazepath_rest, "dta_4gazepath_rest.rds")


```




EXPORTS INDIVIDUAL CSVS
```{r}

# Split the data frame into a list of data frames based on the unique combinations
tmp_split_df <- split(dta_4gazepath1, dta_4gazepath1$split_column)

setwd("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/for_fix_sac")
# Log message indicating the start of writing files for gazepath
message("Writing files for gazepath")

# Iterate over the list of split data frames and write each to a CSV file
walk(names(tmp_split_df), function(tmp_splitcol) {
  write_csv(tmp_split_df[[tmp_splitcol]], paste0('gp_', tmp_splitcol, ".csv"))
})

# Message indicating completion
message("Files successfully written for gazepath")


```





run gazepath to detect fioxationa nd saccades in gaze data


# cerate an emoty rscipt mor mark down then run the lines below
library(gazepath)
GUI() # 


run first stimuli files then fixcation files separately then rest fiules sepaartelly
note you need to close and restart gazepath after each processing

gazepath settings

left eye x coord: left_gaze_x_cor_pix
left eye y coord: left_gaze_y_cor_pix

didtance: distance (mm)

right eye x coord: right_gaze_x_cor_pix
right eye y coord: right_gaze_y_cor_pix
didtance: distance (mm)


sample rate: 150
screen resolution height (pix): 1080
screen resolution width (pix): 1920


stimuli height (px): 1080 
stimuli width (px): 1920
variables to keep: text, participant, pratice_vs_trial, stimnopath_no_na


<!-- bristol -->

USE SCREEN SIZE in mm (update accordingly)
stimuli height mm 275 
stimuli width mm 485

<!-- previous -->
<!-- stimuli height mm 300 -->
<!-- stimuli width mm 530 -->

<!-- # for gazepath run on windows this is what i needed to do -->. 
<!-- THIS DOESN'T RUN IN CURRENT R VERSIONS, WE HAD TO RECREATE THE FUNCTIONS -->
<!-- install rig -->
<!-- R.version -->
<!-- _ -->
<!-- platform       x86_64-w64-mingw32 -->
<!-- arch           x86_64 -->
<!-- os             mingw32 -->
<!-- system         x86_64, mingw32 -->
<!-- status -->
<!-- major          3 -->
<!-- minor          6.3 -->
<!-- year           2020 -->
<!-- month          02 -->
<!-- day            29 -->
<!-- svn rev        77875 -->
<!-- language       R -->
<!-- version.string R version 3.6.3 (2020-02-29) -->
<!-- nickname       Holding the Windsock -->
<!-- install.packages("sp") -->
<!-- install.packages("jpeg") -->
<!-- install.packages("scales") -->
<!-- install.packages("zoo") -->
<!-- install.packages("shiny") -->
<!-- install.packages("gazepath_1.3.tar.gz", repos = NULL, type = "source") -->
<!-- library(gazepath) -->
<!-- GUI() -->


<!-- find old mac versions of r -->
<!-- https://cran-archive.r-project.org/bin/macosx/base/ -->
```{r eval=FALSE, include=FALSE}
# install from source
# download gazepath from source here: https://cran.r-project.org/src/contrib/Archive/gazepath/
# install.packages("path/to/package_name.tar.gz", repos = NULL, type = "source")
# install.packages()
# if (!requireNamespace("devtools", quietly = TRUE))
#   install.packages("devtools")
# devtools::install_github("username/repository")
# install.packages("gazepath_1.3.tar.gz", repos = NULL, type = "source")
# library(gazepath)
# ####################################
# # use rig to run r version 3.6.3 to get correct results, because gazepath has not been updated for R 4+
# GUI()
# 
# ```
```


RUN THE NEW GAZEPATH FUNCTIONS
- SEE https://github.com/hcuve/gazepath




# Stimuli (all ppts)

```{r}
#loading files if they are already loaded
dta_4gazepath_stim <- readRDS("dta_4gazepath_stim.rds")
colnames(dta_4gazepath_stim)

dta_4gazepath_fix <- readRDS("dta_4gazepath_fix.rds")
colnames(dta_4gazepath_fix)

dta_4gazepath_rest <- readRDS("dta_4gazepath_rest.rds")
colnames(dta_4gazepath_rest)

# formatting the data if needed
# dta_4gazepath_stim <- as.data.frame(as.matrix(dta_4gazepath_stim))
# dta_4gazepath_stim[, c(17, 18, 19, 20, 23, 28)] <- lapply(dta_4gazepath_stim[, c(17, 18, 19, 20, 23, 28)], as.numeric)

# Split the data by participant
tmp_stim_by_pp <- split(dta_4gazepath_stim, dta_4gazepath_stim$participant)

# Initialize an empty list to store gazepath results
gazepath_results <- list()

# Initialize an empty dataframe to store summary results
gp_summary_results <- data.frame()

# Loop through each participant's data
for (participant_id in names(tmp_stim_by_pp)) {
  # Get the data for the current participant
  dta <- tmp_stim_by_pp[[participant_id]]

  # Check if the trial column exists and has values
  if (!"trial_no" %in% colnames(dta) || all(is.na(dta$trial_no))) {
    warning(paste("Skipping participant", participant_id, "due to missing or empty 'trial' column"))
    next
  }

  # Ensure the trial column is properly formatted
  dta$trial_no <- as.factor(as.numeric(as.character(dta$trial_no)))

  # Run the gazepath analysis (you can run just the section below if you are running only a single file/particiapnt )
  rslt_gp_stim <- gazepath(dta, 
                           x1 = 17, y1 = 19, 
                           x2 = 18, y2 = 20,
                           d1 = 23, d2 = 23,
                           trial = 28, # Ensure this is a character or factor
                           height_px = 1080, height_mm = 295,
                           width_px = 1920, width_mm = 525,
                           extra_var = c("text", "trial_no", "trial_no_gpid_stim", "stimnopath_no_na", "participant"),
                           method = 'gazepath',
                           samplerate = 150)

  # Append the gazepath result to the list
  gazepath_results[[participant_id]] <- rslt_gp_stim

  # Run the summary analysis
  rslt_fix_sacc_gp <- summary.gazepath(rslt_gp_stim)

  # Bind the summary results into the dataframe
  gp_summary_results <- bind_rows(gp_summary_results, rslt_fix_sacc_gp)
}


# Save gazepath results to an RDS file
saveRDS(gazepath_results, "gazepath_results.rds")
saveRDS(gp_summary_results, "gp_summary_results.rds")
```



stim plots
```{r}

# Example plots that compare before and after to make sure that parsed data matched the raw data
tmp_stim_by_pp$`249` %>%
  subset(trial_no == 28) %>%
  ggplot(aes(as.numeric(gaze_x_cor_pix), as.numeric(gaze_y_cor_pix))) +
  geom_path() +
  geom_path(aes(y = as.numeric(gaze_y_cor_pix)))+
  scale_y_reverse()

tmp_stim_by_pp$`249` %>%
  subset(trial_no == 28) %>%
  ggplot(aes(as.numeric(timerezero), as.numeric(gaze_x_cor_pix))) +
  geom_line() +
  geom_line(aes(y = as.numeric(gaze_y_cor_pix)))+
  ylim(0, 2000)

plot.gazepath(gazepath_results$`249`, trial_index = 28)

```


# Fixations (all ppts)

```{r}

#loading files
dta_4gazepath_fix <- readRDS("C:/Users/st20965/OneDrive - University of Bristol/4th Year Masters/2023-24 Project/Data backup/Eyetracking/preprocessed/for_fix_sac/dta_4gazepath_fix.rds")
colnames(dta_4gazepath_fix)

# formatting the data
dta_4gazepath_fix <- as.data.frame(as.matrix(dta_4gazepath_fix))
dta_4gazepath_fix[, c(17, 18, 19, 20, 23, 28)] <- lapply(dta_4gazepath_fix[, c(17, 18, 19, 20, 23, 28)], as.numeric)

# Split the data by participant
tmp_fix_by_pp <- split(dta_4gazepath_fix, dta_4gazepath_fix$participant)

# Initialize an empty list to store gazepath results
gazepath_results_fix <- list()

# Initialize an empty dataframe to store summary results
gp_summary_results_fix <- data.frame()

# Loop through each participant's data
for (participant_id in names(tmp_fix_by_pp)) {
  # Get the data for the current participant
  dta <- tmp_fix_by_pp[[participant_id]]

  # Check if the trial column exists and has values
  if (!"trial_no" %in% colnames(dta) || all(is.na(dta$trial_no))) {
    warning(paste("Skipping participant", participant_id, "due to missing or empty 'trial' column"))
    next
  }

  # Ensure the trial column is properly formatted
  dta$trial_no <- as.factor(as.numeric(as.character(dta$trial_no)))

  # Run the gazepath analysis (you can run just the section below if you are running only a single file/particiapnt )
  rslt_gp_fix <- gazepath(dta, 
                           x1 = 17, y1 = 19, 
                           x2 = 18, y2 = 20,
                           d1 = 23, d2 = 23,
                           trial = 28, # Ensure this is a character or factor
                           height_px = 1080, height_mm = 295,
                           width_px = 1920, width_mm = 525,
                           extra_var = c("text", "trial_no", "trial_no_gpid_fix", "stimnopath_no_na", "participant"),
                           method = 'gazepath',
                           samplerate = 150)

  # Append the gazepath result to the list
  gazepath_results_fix[[participant_id]] <- rslt_gp_fix

  # Run the summary analysis
  rslt_fix_sacc_gp_fix <- summary.gazepath(rslt_gp_fix)

  # Bind the summary results into the dataframe
  gp_summary_results_fix <- bind_rows(gp_summary_results, rslt_fix_sacc_gp_fix)
}


# Save gazepath results to an RDS file
saveRDS(gazepath_results_fix, "gazepath_results_fix.rds")
saveRDS(gp_summary_results_fix, "gp_summary_results_fix.rds")
saveRDS(tmp_fix_by_pp, "tmp_fix_by_pp.rds")
```

```{r}
# Example plots that compare before and after to make sure that parsed data matched the raw data
tmp_fix_by_pp$`249` %>%
  subset(trial_no == 63) %>%
  ggplot(aes(as.numeric(gaze_x_cor_pix), as.numeric(gaze_y_cor_pix))) +
  geom_path() +
  geom_path(aes(y = as.numeric(gaze_y_cor_pix)))+
  scale_y_reverse()

tmp_fix_by_pp$`249` %>%
  subset(trial_no == 63) %>%
  ggplot(aes(as.numeric(timerezero), as.numeric(gaze_x_cor_pix))) +
  geom_line() +
  geom_line(aes(y = as.numeric(gaze_y_cor_pix)))+
  ylim(0, 2000)

plot.gazepath(gazepath_results_fix$`249`, trial_index = 63)

```




load gazepath data


```{r}

setwd("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/Gazepath results/GPRESULTS")

gazepath_results_stim <- readRDS("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/for_fix_sac/GPRESULTS/gazepath_results.rds")
gp_summary_results_stim <- readRDS("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/for_fix_sac/GPRESULTS/gp_summary_results.rds")

gazepath_results_fix <- readRDS("gazepath_results_fix.rds")
gp_summary_results_fix <- readRDS("gp_summary_results_fix.rds")

gazepath_results_rest <- readRDS("gazepath_results_rest.rds")
gp_summary_results_rest <-readRDS("gp_summary_results_rest.rds")

tmp_rest_by_pp <- readRDS("~/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/Gazepath results/GPRESULTS/tmp_rest_by_pp.rds")

```

summary contains fixation and saccades
```{r}

# Bristol data
setwd("/Users/pw22812/Library/CloudStorage/OneDrive-UniversityofBristol/Research Projects/EmotionPhysio2024/2023-24 Project/Data backup/Eyetracking/preprocessed/Gazepath results")

# dta_gp_all_fix_sacc <- rbindlist(sapply(tmp_filelist[c(1,3,5)], fread, simplify = FALSE),
#                 use.names = TRUE, idcol = "filename2")%>%
#   janitor::clean_names()

gp_summary_results_stim
gp_summary_results_fix
gp_summary_results_rest


# quick checks
gp_summary_results_stim%>%
  ggplot(aes(Duration))+
  geom_histogram()


gp_summary_results_stim%>%
  group_by(trial_no, participant)%>%
  mutate(sum_dur = sum(Duration))%>%
  ggplot(aes(sum_dur))+
  geom_histogram()



gp_summary_results_fix%>%
  group_by(participant,text)%>%
  mutate(sum_dur = sum(Duration))%>%
  # subset(sum_dur > 4000)%>%
  ggplot(aes(sum_dur))+
  geom_histogram()


gp_summary_results_rest%>%
  group_by(participant,text)%>%
  mutate(sum_dur = sum(Duration))%>%
  ggplot(aes(sum_dur))+
  geom_histogram()

tmp_test<- gp_summary_results_fix%>%
  group_by(participant,text)%>%
  mutate(sum_dur = sum(Duration))%>%
  subset(sum_dur > 4000)



```



combine all data into one file

```{r}
dta_gp_all_fix_sacc <- rbind(gp_summary_results_rest, gp_summary_results_fix, gp_summary_results_stim)


# recreate the screen content
dta_gp_all_fix_sacc<- dta_gp_all_fix_sacc%>%
  mutate(
    screencontent_no_na = case_when(
      grepl("fix", text) ~ "fixation_cross",
      grepl("stim", text) ~ "stimuli",
      grepl("rest", text) ~ "rest",
      TRUE ~ NA_character_ # Provides an NA value where none of the above conditions are met
    ),
    screencontent_no = case_when(
      screencontent_no_na == "rest" ~ 1,
      screencontent_no_na == "fixation_cross" ~ 2,
      screencontent_no_na == "stimuli" ~ 3,
      TRUE ~ NA_real_ # Ensures that a numeric NA is returned if none of the conditions match
    )
  )%>%
  arrange(participant,trial_no, screencontent_no)%>%
  janitor::clean_names()


unique(dta_gp_all_fix_sacc$screencontent_no_na)


unique(dta_gp_all_fix_sacc$screencontent_no)
# dta_gp_all_fix_sacc$stim_iaps <- paste0(sub(".*_([^_]+)\\.jpg.*", "\\1", dta_gp_all_fix_sacc$text), ".jpg")
  
dta_gp_all_fix_sacc
# note use trial no - Trial is an index from gazepath
```

create aoi - stim vs not stim

```{r}
dta_gp_all_fix_sacc_stim<- dta_gp_all_fix_sacc%>%
  subset(screencontent_no == 3)
# compute means and max fixation duration

unique(dta_gp_all_fix_sacc_stim$screencontent_no_na)

unique(dta_gp_all_fix_sacc_stim$screencontent_no)

# are they looking at the image
# stim_aoi_vs_non_stim

# Screen dimensions
screen_width <- 1920
screen_height <- 1080

# Image dimensions
image_width <- 1024
image_height <- 768

# Calculate the AOI boundaries (image centred on the screen)
aoi_x_min <- (screen_width - image_width) / 2
aoi_x_max <- aoi_x_min + image_width
aoi_y_min <- (screen_height - image_height) / 2
aoi_y_max <- aoi_y_min + image_height





ggplot()+
  geom_vline( xintercept = 0)+
  geom_vline( xintercept = 1920)+
  geom_hline( yintercept = 0)+
  geom_hline( yintercept = 1080)+
  
    geom_vline( xintercept = 448, colour = "red")+
  geom_vline( xintercept = 1472, colour = "red")+

    geom_hline( yintercept = 156, colour = "red")+
  geom_hline( yintercept = 924, colour = "red")



```
  
  aoi stim not stim
  
```{r}

dta_gp_all_fix_sacc
dta_gp_all_fix_sacc <- dta_gp_all_fix_sacc %>%
  group_by(participant, text)%>%
  # image 1024, 768
  # screen 1080, 1920
  # aoi stim vs non stim
  mutate(aoi_stim_nonstim = ifelse(mean_x >= aoi_x_min & mean_x <= aoi_x_max &
                                     mean_y >= aoi_y_min & mean_y <= aoi_y_max,
                                   "stim_aoi", "nonstim_aoi"),
         aoi_quadrant = case_when(
           mean_x >= aoi_x_min & mean_x <= (aoi_x_min + (aoi_x_max - aoi_x_min) / 2) &
           mean_y >= aoi_y_min & mean_y <= (aoi_y_min + (aoi_y_max - aoi_y_min) / 2) ~ "1",
           
           mean_x > (aoi_x_min + (aoi_x_max - aoi_x_min) / 2) & mean_x <= aoi_x_max &
           mean_y >= aoi_y_min & mean_y <= (aoi_y_min + (aoi_y_max - aoi_y_min) / 2) ~ "2",
           
           mean_x >= aoi_x_min & mean_x <= (aoi_x_min + (aoi_x_max - aoi_x_min) / 2) &
           mean_y > (aoi_y_min + (aoi_y_max - aoi_y_min) / 2) & mean_y <= aoi_y_max ~ "3",
           
           mean_x > (aoi_x_min + (aoi_x_max - aoi_x_min) / 2) & mean_x <= aoi_x_max &
           mean_y > (aoi_y_min + (aoi_y_max - aoi_y_min) / 2) & mean_y <= aoi_y_max ~ "4",
           
           TRUE ~ "nonstim_aoi" # In case the point doesn't fall into any of the quadrants
         ))%>%
  ungroup()


dta_gp_all_fix_sacc_stim%>%
  ggplot(aes(mean_x, mean_y, color = aoi_quadrant))+
  geom_point()+
  # geom_path()+
  facet_grid(~aoi_stim_nonstim)+
  geom_vline( xintercept = 0)+
  geom_vline( xintercept = 1920)+
  geom_hline( yintercept = 0)+
  geom_hline( yintercept = 1080)+
  
    geom_vline( xintercept = 448, colour = "red")+
  geom_vline( xintercept = 1472, colour = "red")+

    geom_hline( yintercept = 156, colour = "red")+
  geom_hline( yintercept = 924, colour = "red")+
  scale_y_reverse()+
  scale_color_brewer(palette = "Dark2")
```


Entropy

entropy of gaze
- stationary
- transition entropy


```{r}
library(entropy)
# install.packages("GrpString")
library(GrpString)

# option 1 - grid option - devide image into a grid
# option 2 - kmean cluster - try this later

  # compute entropy
  # shanon entropy


# Define the number of possible states
num_states <- 5
all_states <- as.character(1:num_states)
max_entropy <- log2(num_states)

unique(dta_gp_all_fix_sacc$aoi_quadrant)


dta_gp_all_fix_sacc$aoi_quadrant<- if_else(dta_gp_all_fix_sacc$aoi_quadrant == "nonstim_aoi", "5", dta_gp_all_fix_sacc$aoi_quadrant )





dta_gp_all_fix_sacc %>%
  group_by(participant, text) %>%
  mutate(
    # Calculate the frequency of each state in aoi_quadrant and add missing states with zero count
    aoi_quadrant_table = list(table(factor(aoi_quadrant, levels = all_states))),
    stat_entropy = entropy::entropy(as.numeric(unlist(aoi_quadrant_table)), unit = "log2") / max_entropy,
    
    # Calculate transition entropy for cluster_label ensuring all states are considered
    trans_entropy = GrpString::TransEntro(as.character(factor(aoi_quadrant, levels = all_states))),
    trans_entropy_perclust = GrpString::TransEntropy(as.character(factor(aoi_quadrant, levels = all_states)))
  ) %>%
  ungroup()








library(dplyr)
library(GrpString)
library(entropy)

# Define the number of possible states
num_states <- 5
all_states <- as.character(1:num_states)
max_entropy <- log2(num_states)

# Adjust the `aoi_quadrant` column
dta_gp_all_fix_sacc$aoi_quadrant <- if_else(dta_gp_all_fix_sacc$aoi_quadrant == "nonstim_aoi", "5", dta_gp_all_fix_sacc$aoi_quadrant)

# Calculate entropy and transition entropy
dta_gp_all_fix_sacc <- dta_gp_all_fix_sacc %>%
  group_by(participant, text) %>%
  mutate(
    # Calculate the frequency of each state in aoi_quadrant and add missing states with zero count
    aoi_quadrant_table = list(table(factor(aoi_quadrant, levels = all_states))),
    stat_entropy = entropy::entropy(as.numeric(unlist(aoi_quadrant_table)), unit = "log2") / max_entropy,
    
    # Calculate transition entropy for aoi_quadrant ensuring all states are considered
    trans_entropy = if (length(unique(aoi_quadrant)) > 1) {
      GrpString::TransEntro(as.character(factor(aoi_quadrant, levels = all_states)))
    } else {
      NA_real_
    },
    
    trans_entropy_perclust = if (length(unique(aoi_quadrant)) > 1) {
      GrpString::TransEntropy(as.character(factor(aoi_quadrant, levels = all_states)))
    } else {
      NA_real_
    }
  ) %>%
  ungroup()

# Check results
head(dta_gp_all_fix_sacc)




library(dplyr)
library(GrpString)
library(entropy)

# Define the number of possible states
num_states <- 5
all_states <- as.character(1:num_states)
max_entropy <- log2(num_states)

# Adjust the `aoi_quadrant` column
dta_gp_all_fix_sacc$aoi_quadrant <- if_else(dta_gp_all_fix_sacc$aoi_quadrant == "nonstim_aoi", "5", dta_gp_all_fix_sacc$aoi_quadrant)

# Calculate entropy and transition entropy
dta_gp_all_fix_sacc <- dta_gp_all_fix_sacc %>%
  group_by(participant, text) %>%
  mutate(
    # Calculate the frequency of each state in aoi_quadrant and add missing states with zero count
    aoi_quadrant_table = list(table(factor(aoi_quadrant, levels = all_states))),
    stat_entropy = entropy::entropy(as.numeric(unlist(aoi_quadrant_table)), unit = "log2") / max_entropy,
    
    # Ensure self-transitions are considered by checking the unique states length
    trans_entropy = GrpString::TransEntro(as.character(factor(aoi_quadrant, levels = all_states))),
    trans_entropy_perclust = GrpString::TransEntropy(as.character(factor(aoi_quadrant, levels = all_states)))
  ) %>%
  ungroup()

# Check results
head(dta_gp_all_fix_sacc)



```


```{r}
# num_states<- 3
# all_states<- as.character(1:3)

test1_2<- c(1,2,1,1,1,2)
table(factor(test1_2))
table(factor(test1_2, levels = all_states))

tmp_test_table<- list(table(factor(test1_2, levels = all_states)))
entropy::entropy(as.numeric(unlist(tmp_test_table)), unit = "log2")
    
table(test1_2)


table(test1_4)
test1_4<- c(1,2,3,1,2,3)

entropy::entropy(test1_2)

entropy::entropy(test1_4)
# 1.735126
?entropy::entropy
?GrpString::TransEntro

GrpString::TransEntro(test1_2)
GrpString::TransEntro(test1_4)


```
dta_gp_all_fix_sacc$participant

dta_gp_all_fix_sacc$ssid <- substr(dta_gp_all_fix_sacc$participant,4,6)

dta_gp_all_fix_sacc_stim<- dta_gp_all_fix_sacc %>%
  subset(screencontent== "stimuli")


dta_gp_all_fix_sacc_stim$trial



```

dta_gp_all_fix_sacc%>%
      subset(ssid== 140 & stim_iaps== "6300.jpg" & screencontent == "stimuli")%>%
   ggplot(aes(start, mean_y))+
  geom_line(aes(y = mean_x))+
  geom_line()

dta_4gazepath$stimnopath
 


to do
Ruth will use imagej (fiji) to compute centre of mass, gray values and histograms.
we'll use centre of mass to compute a proxy of image eccentricity (centroid of entre of mass - image centroids - euclidian distance)

# consider normalising the eccentricity based on eccentricity of the image


# stim 1 = ecc 10 (more content away)
# stim 2= ecc 5 (more content in the centre)
# 
# # gaze
# gaze 1 = ecc 4
# gaze 2 = ecc 4
# 4/10 = 0.4
# 4/5 = 0.8
# 

  
https://rdrr.io/rforge/CulturalAnalytics/man/imageEntropy.html

```{r}


# https://uk.mathworks.com/help/images/ref/entropy.html
# Entropy is defined as -sum(p.*log2(p)), where p contains the normalized histogram counts returned from imhist.

```



 
```{r}


dta_gp_all_fix_sacc_stim_agg<- dta_gp_all_fix_sacc_stim %>%
  group_by(participant,ssid, text, trial, stim_iaps) %>%
  


  summarise(
    mean_dwell_dur = mean(duration, na.rm = TRUE),
    mean_fix_dur = mean(duration[value == "f"], na.rm = TRUE),
    mean_sac_dur = mean(duration[value == "s"], na.rm = TRUE),
    sum_dwell_dur = sum(duration, na.rm = TRUE),
    sum_fix_dur = sum(duration[value == "f"], na.rm = TRUE),
    sum_sac_dur = sum(duration[value == "s"], na.rm = TRUE),
    mean_rms = mean(rms, na.rm = TRUE),
    mean_po_gsd = mean(po_gsd_sac_amp[value == "f"], na.rm = TRUE),
    mean_sac_amp = mean(po_gsd_sac_amp[value == "s"], na.rm = TRUE),
    count_fix = sum(value == "f"),
    count_sacc = sum(value == "s")
    # .groups = "drop" # This explicitly drops the grouping instead of keeping it
  )%>%

  # Optionally, ungroup if you want to remove the grouping structure
  ungroup()
```


```{r}
dta_gp_all_fix_sacc_stim_agg%>%
      # subset(ssid!= 140)%>%
  group_by(participant,ssid)%>%

  summarise_if(is.numeric, max, na.rm = T)%>%
  ggplot(aes( sum_dwell_dur,participant))+
  # geom_point()+
  geom_text(aes(label = ssid))



```

```{r}
dta_gp_all_fix_sacc_stim_agg%>%
      subset(ssid== 140)%>%
  group_by(participant,stim_iaps)%>%

  summarise_if(is.numeric, max, na.rm = T)%>%
  ggplot(aes( sum_dwell_dur,stim_iaps))+
  # geom_point()+
  geom_text(aes(label = stim_iaps))


```


dta_gp_all_fix_sacc_stim_agg<- dta_gp_all_fix_sacc_stim_agg%>%
      subset(ssid== 140)


  

# add trackloss

colnames(dta_4gazepath)
dta_4gazepath$split_column
dta_4gazepath$screencontent_no_na

dta_4gazepath$stimnopath
trackloss<- dta_4gazepath%>%
  select(participant, screencontent_no_na,text, gaze_valid_prop)%>%
  subset(screencontent_no_na == "stimuli")%>%
  select(-screencontent_no_na)%>%
  group_by(participant, text) %>%
  summarise_at(c("gaze_valid_prop"), mean, na.rm = T)%>%
  mutate(gaze_valid_prop_ppt = mean(gaze_valid_prop, na.rm = T))


dta_gp_all_fix_sacc_stim_agg<- left_join(dta_gp_all_fix_sacc_stim_agg, 
                                                 trackloss, by = c("participant", "text"))
```


to merge

```{r}

dta_gp_all_fix_sacc_stim_agg

```





# debugging
(automated description of the problem based on context I provided)

Summary of the Problem:
You are experiencing inconsistencies when processing eye-tracking data using the gazepath method. Specifically, certain trials appear to be "flipped" or mismatched when processed together, but not when processed separately. The main issues are:

Data Flipping:

When trials 6300.jpg and 111.jpg are processed together, their visualizations match each other’s raw data, indicating a possible mix-up.
When these trials are processed separately, the visualizations match their respective raw data correctly.
Consistency Across Runs:

When running the same trials multiple times in a row, you need to ensure the patterns remain consistent.
Similarly, when running combined trials multiple times, the results should be consistent.
Order Sensitivity:

Changing the order of the trials might affect the results, indicating a possible issue with how trials are indexed or handled during processing.
Participant Specificity:

Check if the problem is specific to certain participants or if it occurs across different participants.
Problematic vs. Good Trials:

Determine if the issue only occurs with problematic trials (6300.jpg and 111.jpg) or if it also affects good trials (112.jpg).
Goals for Debugging:
Replicate Patterns Separately:

Verify if processing each trial separately produces correct and consistent results.
Check Repeatability:

Run the same trial multiple times to ensure the results are consistent each time.
Combine and Re-run Trials:

Combine multiple trials for a participant and run the processing multiple times to check for consistency.
Re-arrange and Test Order:

Change the order of trials and run the processing multiple times to see if the order affects the results.
Cross-Participant Testing:

Test the same problematic trials with data from different participants to see if the issue persists.
By following these steps, you can identify whether the issue lies in the trial handling, data indexing, or some other part of the processing pipeline. This will help you pinpoint the cause of the data flipping and ensure reliable and consistent processing of your eye-tracking data.
```{r}
tmp_140<- dta_4gazepath%>%
  subset(ssid == 140)

tmp_140


tmp_140%>%
  mutate(duplicated_event_id = duplicated(event_id) | duplicated(event_id, fromLast = TRUE),
         duplicated_time = duplicated(time) | duplicated(time, fromLast = TRUE)) %>%
  ungroup()
tmp_140%>%
  filter(!duplicated_event_id & !duplicated_time)%>%
  subset(screencontent == "stimuli")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_point()+
  facet_grid(~screencontent)


# 111
# 6300

dta_4gazepath%>%
  subset(ssid == 140)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "111.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 140; 111.jpg")




dta_4gazepath%>%
  subset(ssid == 140)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "6300.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 140; 6300.jpg")


dta_4gazepath%>%
  subset(ssid == 140)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "112.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 140; 112.jpg")





dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "111.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 215; 111.jpg")




dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "6300.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 215; 6300.jpg")


dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "112.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 215; 112.jpg")



dta_4gazepath%>%
  subset(ssid == 215)%>%
  subset(screencontent == "stimuli" & stimnopath_no_na == "2457.jpg")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y =gaze_y_cor_pix))+
  facet_grid(~screencontent)+
  ggtitle("pp 249; 2457.jpg")

```



```{r}

dta_4gazepath%>%
  # subset(ssid == 142)%>%
  # mutate(duplicated_event_id = duplicated(event_id) | duplicated(event_id, fromLast = TRUE),
  #        duplicated_time = duplicated(time) | duplicated(time, fromLast = TRUE)) %>%
  ungroup()%>%
  arrange(time)%>%
  filter(!duplicated_event_id & !duplicated_time)%>%
  subset(screencontent == "stimuli")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_point()+
  facet_grid(~screencontent)
  
  
```



dta_4gazepath%>%
  subset(ssid == 142)%>%
  arrange(time)%>%
  subset(screencontent == "stimuli")%>%
  ggplot(aes(timerezero,gaze_x_cor_pix))+
  geom_point()+
  facet_grid(~screencontent)





# debug
unique(dta_4gazepath$stimnopath)

dta_4gazepath%>%
      subset(ssid== 140 & stimnopath == "6300.jpg" & screencontent == "stimuli")%>%
   ggplot(aes(timerezero, gaze_y_cor_pix))+
  geom_line(aes(y = gaze_x_cor_pix))+
  geom_line()


dta_4gazepath$text


dta_4gazepath%>%
      subset(ssid== 140 & stimnopath == "2457.jpg" & screencontent == "stimuli")%>%
   ggplot(aes(timerezero, gaze_y_cor_pix))+
  geom_line(aes(y = gaze_x_cor_pix))+
  geom_line()
  
  
```

tmp<- dta_4gazepath%>%
      subset(ssid== 141 & stimnopath == "2457.jpg" & screencontent == "stimuli")

tmp1<- dta_4gazepath%>%
      subset(ssid== 140 & stimnopath == "111.jpg" & screencontent == "stimuli")


tmp1<- dta_4gazepath%>%
      subset(ssid== 141 & stimnopath == "111.jpg" & screencontent == "stimuli")

tmp
tmp1

```{r}

colnames(dta1)
tmp_140 <- gazepath(dta1, x1 = 17, y1 = 19, x2 = 18, y2 = 20, d1 = 23, d2 = 23, trial = 5,
height_px = 1080, height_mm = 295,
width_px = 1920, width_mm = 525, extra_var = c("text","participant","stimnopath_no_na"),
method = 'gazepath', samplerate = 150)
install.packages("tidyverse")
library(tidyverse)
ppt140%>%
  subset(stimnopath_no_na == "111.jpg")%>%
  ggplot(aes(timerezero,right_gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y=right_gaze_y_cor_pix))



```




```{r}

unique(dta_4gazepath$text)



dta_4gazepath_stim<- subs

# Function to extract the last part after an underscore
get_last_part <- function(x) {
  parts <- strsplit(x, "_")[[1]]
  return(tail(parts, n=1))
}


# Print the result
print(result)

unique(dta_4gazepath$text)[2]

dta_4gazepath$trial_no<- stringr::str_match(dta_4gazepath$text, '(.*)_(.*)')[, -1][,2]
unique(dta_4gazepath$trial_no)[2]

dta_4gazepath$trial_no<- if_else(dta_4gazepath$trial_no == "cross",0, as.numeric(dta_4gazepath$trial_no))


unique(dta_4gazepath$trial_no)
unique(dta_4gazepath$pratice_vs_trial)

dta_4gazepath$trial_no<- if_else(dta_4gazepath$pratice_vs_trial == "Pratice", 
                                         dta_4gazepath$trial_no+1,dta_4gazepath$trial_no)
                                 
                                 
dta_4gazepath$trial_no<- if_else(dta_4gazepath$pratice_vs_trial == "Trial",
                                  dta_4gazepath$trial_no+5,    dta_4gazepath$trial_no)


unique(dta_4gazepath$trial_no)
table(is.na(dta_4gazepath$trial_no))

tmp<- dta_4gazepath%>%subset(pratice_vs_trial == "rest")

unique(tmp$trial_no)

unique(dta_4gazepath$pratice_vs_trial)

# Pratice
tmp<- dta_4gazepath%>%subset(pratice_vs_trial == "Pratice")

unique(tmp$trial_no)


tmp<- dta_4gazepath%>%subset(pratice_vs_trial == "Trial")

unique(tmp$trial_no)


dta_4gazepath$trial_no_gpid_stim<- paste0(dta_4gazepath$trial_no, paste0("_"),
                                          dta_4gazepath$stimnopath_no_na)


dta_4gazepath$trial_no<- as.factor(as.numeric(dta_4gazepath$trial_no))

dta_4gazepath




```






```{r}
dta_4gazepath_stim
dta_4gazepath_stim

dta_140<- dta_4gazepath_stim%>%
  subset(ssid == 141)


# dta_140$trial_no_id_plus5trial<- as.factor(dta_140$trial_no_id_plus5trial)

colnames(dta_140)

dta_140$trial_no<- as.factor(dta_140$trial_no)

dta_140$trial_no<- as.numeric(dta_140$trial_no)

ppt140 <- gazepath(dta_4gazepath_stim, x1 = 17, y1 = 19, x2 = 18, y2 = 20,
                   d1 = 23, d2 = 23,
                   trial = 28, #it needs to be character or factor
height_px = 1080, height_mm = 295,
width_px = 1920, width_mm = 525, 
# extra_var = c("text","participant", "trial_no_gpid_stim","trial_no"),
method = 'gazepath', 
samplerate = 150)
```
```{r}
ppt140_parsed<- summary(ppt140)
ppt140_parsed%>%
  subset(ppt140_parsed$trial_no_id_plus5trial_stim == "5_111.jpg")
as.factor(dta_140$trial_no_id_plus5trial)
dta_140%>%
  subset(stimnopath_no_na == "111.jpg")%>%
  ggplot(aes(timerezero,right_gaze_x_cor_pix))+
  geom_line()+
  geom_line(aes(y=right_gaze_y_cor_pix))
plot(ppt140, trial_index = 6)

```







# eccentricity within image and whole screencontent_no_na



# Calculate the Euclidean distance from the centre for each gaze point

dta_gp_all_fix_sacc

dta_gp_all_fix_sacc<- dta_gp_all_fix_sacc %>%
  mutate(dist_from_cntr_whole_screen = sqrt((mean_x - (screen_width/2))^2 + (mean_y - (screen_height/2))^2))%>%
  group_by(participant,text, aoi_stim_nonstim)%>%
  
  mutate(dist_from_cntr_stim = 
                                 sqrt((mean_x - (screen_width / 2))^2 + (mean_y - (screen_height / 2))^2))




```